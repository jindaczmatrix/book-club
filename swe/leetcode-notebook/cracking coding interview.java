序
亲爱的读者，

让我们先来介绍一下。

我不是招聘人员。我是一名软件工程师。正因如此，我知道被要求当场拿出精彩的算法然后在白板上编写出完美的代码是什么感觉。我之所以知道，是因为我被要求做过同样的事情——在 Google、Microsoft、Apple 和 Amazon 以及其他公司的面试中。

不仅如此，我也曾站在桌子的另一边，要求我的候选人们也这样做。我曾经为了找到那些我认为有可能通过面试的工程师，而翻看过成堆的简历。我曾经在他们解决或试图解决具有挑战性的问题时，对他们进行评估。我也曾经在 Google's Hiring Committee 中争论过，是否某个候选人的表现足以获得这份工作。我熟悉整个招聘流程，因为我经历过其中的每一步，一遍又一遍。

而你，读者，可能正在为明天、下周或明年的面试做准备。我在这是为了帮助你巩固对计算机科学基础的理解，然后学习如何应用这些基础知识来破解编码面试。

第 6 版 Cracking the Coding Interview 在第 5 版的基础上进行了更新，增加了 70% 的内容：附加问题、修订后的答案、新章节介绍、更多的算法策略、所有问题的提示以及其他内容。请务必访问我们的网站 CrackingTheCodinglnterview.com，与其他求职者联系并发现新资源。

我为你和你将要发展的技能感到高兴。充分的准备将有助于你拓宽知识范围、提升沟通技巧。无论付出多大的努力，这都是值得的！建议你仔细阅读这些入门章节，在这些章节我记录下了一些重要的见解，或许最终能影响你的结果是 "hire"，还是 "no hire"。

同时要牢记，面试是很难的！在 Google 搞面试的这几年里，我注意到有一些面试官会问“简单”的问题，而另外一些面试官会问稍难的问题。但是你猜怎么着？简单的问题并不会让你更容易获得 offer。获得 offer 并不是要求你能完美地解决问题（很少有求职者能够做到！），而是要求你能给出比其他的求职者更好的回答。所以，当你遇到棘手的问题时，不要紧张——其他人可能都认为它很难。做不到完美也没有关系。

Study hard, practice-and good luck!

Gayle L. McDowell 创始人/CEO, CareerCup.com Cracking the PM Interview 和 Cracking the Tech Career 作者

引言
哪里错了
我们再次沮丧地走出招聘会。那天考察的 10 位候选人中，没有一位会收到 offer。我们在想，我们是不是太苛刻了？

我尤其感到失望。我们拒绝了我的一位候选人。他是我之前教过的一个学生。他在世界上最好的计算机科学学校之一华盛顿大学取得了 3.73 的 GPA，并在开源项目上做了大量工作。他精力充沛。他很有创造性。他很敏锐。他工作努力。他在所有方面都是一个真正的极客。

但我不得不同意委员会其他成员的观点：这些数据并不能说明问题。即使我强烈的推荐能够说服他们重新考虑，他也肯定会在后面的招聘流程中遭到淘汰。因为他暴露了太多的危险信号（red flag）。

虽然他很聪明，但是在解决面试问题时他却表现得很艰难。面试中的第一个问题是一个经典问题的变形，大多数成功的求职者都能快速做出回答，但是他却在这个问题的算法开发时遇到了麻烦。当他提出一个方案时，没有考虑到针对其他场景优化的解决方案。最终在编码时，他用最初的解决思路快速地写完了代码，但是代码中却充满了他没有留意到的错误。尽管从任何角度来看，他都不是我们所见过的最差的候选人，但是他离 “bar” （译者注，标杆）还差得很远。所以，拒绝。

几周后，当他在电话中询问反馈时，我很纠结不知道该怎么回答他。更聪明？不，我知道他很聪明。成为更好的 coder？不，他的技术和我见过的一些最好的不相上下。

像许多积极的求职者一样，他准备得很充分。他读过 K&R 的经典 C 语言书籍，也复习过 CLRS 著名的算法教科书。他可以详细描述平衡树的无数种方法，而且他可以用 C 语言做一些没有任何理智的程序员会考虑做的事情。

我不得不告诉他一个不幸的事实：仅仅看那些书是不够的。学术书籍能让你为新奇的研究做好准备，它们可能会让你成为一名更好的软件工程师，但它们不足以应对面试。为什么？我给你个提示：你的面试官没有见过红黑树，因为他们在学校也是如此。

要破解编码面试，你需要准备真实的面试问题。你必须对实际问题进行练习，并学习它们的模式。最终能实现灵活开发新的算法，而不是死记硬背现有的问题。

Cracking the Coding Interview 一书是我根据在一线公司参与面试并在之后指导求职者通过面试的第一手经验所总结的成果。它是与求职者数百次对话的成果。它是汇总候选人和面试官提出的数千个问题的成果。它也是参考了这么多公司的这么多面试问题的成果。本书收录了 189 个最好的面试问题，这是从成千上万个可能的问题中挑选出来的。

我的方法
Cracking the Coding Interview 的重点是算法、编码和设计问题。为什么？因为虽然你可以也会被问到工作经验方面的问题（behavioral question），但答案会和你的简历一样五花八门。同样，虽然许多公司会问一些所谓的 “trivia” 问题（例如，“什么是虚拟功能？”），但是通过实践这些问题而获得的技能仅限于非常具体的知识。本书将简要介绍其中的一些问题，向你展示它们是什么样的，但我选择将空间分配给需要学习更多内容的领域。

我的爱好
教学是我的爱好。我喜欢帮助人们理解新概念，并为他们提供工具来帮助他们在他们爱好的领域中脱颖而出。

我第一次正式的教学经历是宾夕法尼亚大学，当时我在第二年成为一名计算机科学本科课程的助教。我接受了 TA 的其他几门课程，最后我在那里开设了自己的计算机科学课程，侧重于实践技能。

作为 Google 的工程师，培训和指导新工程师是我最喜欢的事情之一。我甚至利用我的 “20％ 时间” 在华盛顿大学教授两门计算机科学课程。

多年后的今天，我继续教授计算机科学的概念，但这一次的目标是让初创公司的工程师为他们的 acquisition interview 做准备。我已经看到他们的错误和努力，并且为帮助他们解决这些问题制定了技术和策略。

Cracking the Coding Interview、Cracking the PM Interview、Cracking the Tech Career 和 CareerCup，都体现了我对教学的热爱。即使是现在，你也经常可以在 CareerCup.com 上看到我在 “闲逛”，以帮助那些寻求帮助的用户。

加入我们。

Gayle L. McDowell

I. 面试过程
在大多数顶级科技公司（以及许多其他公司），算法和编码问题是面试过程中最大的组成部分。这类问题都可以被视为问题解决型（problem-solving）的问题。面试官希望能通过观察你解决以前没有遇到过的算法问题的过程，来评估你的能力。

很多时候，在面试中你可能只会遇到一个问题。因为 45 分钟并不长，在这段时间内你很难全部回答完几个不同的问题。

在整个解决问题的过程中，你应该大声地说出你的方案，并解释你的思考过程。你的面试官有时会跳出来引导你，让他们这样做。这是正常的，并不意味着你做得很差。(当然，不需要提示就更好了。)

在面试结束后，面试官一般会对你的表现就已经有了直观的感觉。他们可能会给你的表现打分，但这并不是一个定量的评价。没有图表显示你在不同的事情上得到了多少分。面试本身就不像是那样工作。

相反，你的面试官对你的表现进行评估，通常是基于以下几点：

分析能力：你需要很多帮助来解决问题吗？你的解决方案有多优？你花了多长时间才找到解决办法？如果你必须设计/架构一个新的解决方案，你是否很好地组织了问题并考虑了不同决策的权衡？

编码水平：你是否能够将算法成功转换为合理的代码？它干净有序吗？你是否考虑过潜在的错误？ 你的代码风格好吗？

技术知识/计算机科学基础知识：你是否拥有计算机科学和相关技术的坚实基础？

经验：你过去做过很好的技术决策吗？你做过有趣、有挑战性的项目吗？你是否表现出动力、主动性和其他重要因素？

文化契合/沟通技巧：你的个性和价值观是否与公司和团队契合？你和面试官是否能够良好沟通？

这些领域的权重将根据问题、面试官、角色、团队和公司的不同而有所不同。在一个标准算法问题中，它主要考察的几乎完全是前三个方面。

Why?
这是求职者在开始面试时最常问的问题之一。为什么面试要设计成这样？毕竟：

很多优秀的求职者在这类面试中都表现不佳。

如果确实出现过，你可以直接查找到答案。

在实际工作中，很少需要使用诸如二叉搜索树之类的数据结构。如果你确实需要，你肯定可以学习它。

白板编码是一种人为的环境。显然，在实际工作中你永远不会在白板上编写代码。

这些抱怨不无道理。事实上，我同意他们所有人的观点，至少部分是这样。

与此同时，我们有理由对某些职位（而不是所有职位）采取这种做法。同意这个逻辑并不重要，但是理解为什么要问这些问题是一个好主意。它能帮助你深入了解面试官的心态。

漏报（False negatives）是可以接收的。
这让人难过（也让候选人感到沮丧），但这却是事实。

从公司的角度来看，一些优秀的候选人被拒其实是可以接受的。如果这家公司打算自己培养一批优秀的员工，他们可以接受错过一些优秀的人。当然，他们也不想这么做，因为这会增加他们的招聘成本。不过，这是一个可以接受的折衷方案，只要他们仍然能够聘用到足够多的优秀人才。

他们更关心的是误报（false positives）：那些在面试中表现很优秀的人，但实际上并不是很优秀。

解决问题的能力（Problem-solving skills）很有价值。
如果你能够解决几个难题（或许是在一定的帮助下），那么你可能非常擅长开发最优算法。换句话说，你很聪明。

聪明的人倾向于将事情做好，这对公司来说很有价值。当然，这不是唯一重要的，但这是一件非常好的事情。

基本数据结构和算法知识很有用。
许多面试官会认为，基本的计算机科学知识实际上是有用的。要清楚，需要用到树、图、列表、排序和其他知识的情况隔段时间肯定会出现。如果真是这样的话，掌握书本的知识真的很有必要。

难道不可以遇到问题的时候根据需要有选择地学习吗？当然可以。但是如果你不知道二叉搜索树的存在，你就很难在需要的时候知道应该去使用它。如果你知道它的存在，那么你具有了基本的概念。

其他面试官依靠数据结构和算法相关的问题来考察求职者，是因为他们认为这是一个很好的“代理”。即使这些技能本身并不难学，但他们表示，这与成为一名优秀的开发人员是有相当大的关联的。这意味着你要么通过了计算机科学课程（在这种情况下，你已经学习并保留了相当广泛的技术知识），要么自学了这些东西。无论哪种方式，这都是一个好迹象。

数据结构和算法知识出现的另一个原因是：很难提出不涉及它们的问题解决型（problem-solving ）的问题。事实证明，绝大多数解决问题的问题涉及其中一些基础知识。当足够多的应聘者了解这些基本知识时，很容易进入一种向他们提问的模式。

白板能让你专注于重要的事情。
在白板上编写完美的代码是非常困难的，这是绝对肯定的。幸运的是，你的面试官对此并没有苛求。实际上，每个人都有一些 bug 或轻微的语法错误。

白板的好处在于，在某种程度上，你可以专注于大局。你没有编译器。所以你不需要编译代码。你不需要编写整个类定义和样板代码。你可以关注代码中有趣的、“充实的”部分：该问题真正关注的功能。

这并不是说你应该只写伪代码或者正确性无关紧要。大多数面试官不接受伪代码，并且希望错误越少越好。

白板也倾向于鼓励候选人多发言，并解释他们的思维过程。当给应聘者一台电脑时，他们的沟通能力会大幅下降。

但这并不适用于每个人、每个公司或每种情况。
以上部分旨在帮助你了解公司的思维过程。

我的个人想法？ 对于正确的情况，如果面试过程处理得当，是能够帮助对一个人解决问题能力做出的合理判断的，因为表现优秀的人往往相当聪明。

然而，许多面试过程体验的并不好。你可能会遇到你的面试官很差劲，或者他们问的问题也很差劲。

它也不适合所有的公司。有些公司应该更重视员工以前的经验，或者需要掌握特定技术的技能。那么这类问题并没有太大分量。

它也不能衡量一个人的职业道德或专注力。再说一次，几乎没有面试过程能真正评估这一点。

无论如何，这都不是一个完美的过程，但什么是完美的过程呢？事实上所有的面试过程都有其缺点。

我只能说：事情就是这样，所以我们只能尽自己所能。

面试题是如何被选择的
应聘者经常会问在某家公司“最近”的面试问题是什么。仅仅问这个问题就揭示了他对问题来源的根本性误解。

在绝大多数公司，面试官该问的问题并没有一个清单。相反，每个面试官都会选择他们自己的问题。

因为就问题而言，它是“对任何人都开放的（free for all）”，所以没有什么能让一个问题成为“最近 Google 面试的问题”，除了一个碰巧在 Google 工作的面试官最近碰巧问了这个问题。

今年 Google 面试被问到的的问题与三年前的问题并没有太大区别。事实上， Google 提出的问题通常与在类似公司（Amazon、Facebook等）提出的问题没有什么不同。

不同公司之间存在着一些广泛的差异。一些公司专注于算法（通常被用于一些系统设计），而另一些公司则非常喜欢基于知识的问题。但在一个给定的问题类别中，几乎没有什么能让它“属于”一家公司，而不是另一家公司。Google 的算法问题和 Facebook 的算法问题本质上是一样的。

一切都是相对的
如果没有评分系统，你是如何被评估的？面试官如何知道你的期望？

好问题。一旦理解了，答案就会变得很有意义。

面试官会通过在同一个面试官的同一个问题上的表现评估你与其他候选人的优劣。这是一个相对比较。

例如，假设你想出了一个很酷的新脑筋急转弯或数学问题。你问你的朋友 Alex 这个问题，他花了30分钟来解决它。你问 Bella，她花了50分钟。Chris 永远也解不出来。Dexter 需要15分钟，但你必须给他一些重要的提示，如果没有这些提示，他可能会花更长的时间。Ellie 采用了 10 种方法，并提出了一个你甚至都不知道的替代方法。Fred 需要35分钟。

你会走开，说道，“哇，Ellie 表现得真不错。我敢打赌她的数学一定很好。”（当然，很有可能只是她比较走运，而 Chris 不走运。你可能会问更多的问题，以确保这不是因为运气好或运气坏。）

面试问题也是如此。面试官通过将你与其他人进行比较，会对你的表现有所了解。当然这和她那周面试的候选人无关，而是基于她曾经问过这个问题的所有候选人的表现。

因此，被问到一个很难的问题并不是一件坏事。如果对你来说很难，那对每个人来说也都是很难的。这并不会降低你成功的可能性。

FAQ
我在面试后没有立即收到回复。我被拒绝了吗？
不。公司的决定可能会被推迟，原因有很多。一个非常简单的解释是，你的一位面试官还没有给出他们的反馈。很少有公司的政策是不回应他们拒绝的候选人。

如果你在面试后的 3~5 个工作日内没有收到任何公司的回复，礼貌地和招聘人员联系。

我被拒绝后可以重新申请公司吗？
几乎都是可以的，但你通常需要等待一段时间（6 个月到 1 年）。当你重新面试时，你的第一次不良面试通常不会对你产生太大的影响。许多人曾被 Google 或 Microsoft 拒绝过，但后来都得到了他们的 offer。

II. 幕后
大多数公司的面试方式都非常相似。本章我们将概述一些公司面试的方式以及什么是他们所看重的。这些信息将指导你如何进行面试准备，以及面试中和面试后该如何表现。

一旦你被选中参加面试，你通常要经过一次筛选面试。这通常是通过电话进行的。而就读于名校的应届求职者将很可能是面对面现场体验这类面试的。

别让这个名字迷惑了你，“筛选”面试通常涉及编码和算法问题，并且面试的门槛可能和面对面面试（in-person interview）一样高。如果你不确定面试是否是技术性的，问问你的招聘协调人你的面试官所担任的职位（或面试可能涵盖的范围）。例如，如果是工程师的话，通常会进行技术面试。

许多公司都利用了在线同步文档编辑器，但也有一些公司希望你将代码写在纸上，然后在电话里向面试官将其读回。甚至，有些面试官会在挂电话后给你布置“家庭作业”，或者只是让你把写的代码通过电子邮件发给他们。

在进行现场面试（on-site）之前，你通常要经过一两个面试官的筛选。

在现场面试中，你通常会有 3 到 6 次面对面的面试。其中之一经常是在午餐时间。午餐面试通常不是技术性的，面试官甚至可能不会提交反馈。你可以与面试官讨论你的兴趣爱好，或者也可以询问公司的企业文化。你的其他面试大多是技术性的，涉及编码、算法、设计/架构和工作经历/经验问题的组合。

由于公司的优先级、规模和纯粹的随机性，上述主题范围内的问题在不同公司甚至不同团队之间的分布都不相同。面试官在面试问题上通常有很大的自由度。

面试后，面试官会以某种形式提供反馈。在一些公司，面试官会聚在一起讨论你的表现并做出决定。在其他公司，面试官会向招聘经理或招聘委员会提交一份建议，以做出最终决定。也有一些公司，面试官甚至不做决定，他们的反馈会被直接提交给招聘委员会，由他们来做决定。

大多数公司在一周后就会采取下一步行动（发offer、拒绝、进一步面试，或者只是更新流程）。一些公司的反馈速度很快（有时是同一天！），而另一些公司的反应时间要长得多。

如果你已经等了一个多星期，你应该跟招聘人员联系一下。如果你的招聘人员没有回应，这并不意味着你就被拒绝了（至少在任何大型科技公司以及几乎所有其他公司中都没有这种情况）。让我再重复一遍：不回复跟你的面试状态并无直接联系。换句话说，一旦做出最终决定，所有招聘人员都应当会告诉求职者。

延迟可能而且确实会发生。如果预计会有延迟，请与招聘人员联系，但这样做时要保持尊重。招聘人员和你一样，他们有时也会忙碌和健忘。

Microsoft 面试
Microsoft 想要聪明的人、极客、热爱科技的人。你可能不会被考察 C++ AP l的输入输出，但是你需要做到在白板上编写代码。

在一个典型的面试中，你将在早上的某个时间出现在 Microsoft，填写一些基础资料。接着你将有一个简短的面试，招聘人员会给你一个简单的问题。招聘人员通常是为了帮你做准备，而不是盘问你技术问题。如果你被问到一些基本的技术问题，那可能是因为你的招聘人员想让你轻松地进入面试，这样当“真正的”面试开始时，你就不会那么紧张了。

善待你的招聘人员。你的招聘人员可能是你最大的支持者，如果你在第一次面试中遇到失误，他们甚至会敦促你重新面试。他们可以为你争取工作——或者不争取！

白天，你将进行四到五次面试，通常是由两个不同的团队来执行。不像许多公司，你在会议室会见面试官，在 Microsoft，你会与面试官在他们的办公室会见。这是一个很好的时机，你可以看看周围，感受一下团队文化。

根据团队的不同，面试官可能会也可能不会将他们对你的反馈分享给面试的其他环节。

当你完成对一个团队的面试时，你可能会与招聘经理交谈（通常被称为“as app”，即“as appropriate”的缩写）。如果是这样，那是一个好兆头！这很可能意味着你通过了一个特定团队的面试。现在就看招聘经理的决定了。

你可能会当天收到决定，也可能是一个星期。在一周没有人力资源部门的消息后，发一封友好的电子邮件询问状态更新。

如果你的招聘人员反应不积极，那是因为她很忙，而不是因为你被默默拒绝了。

必要的准备：
“你为什么想为 Microsoft 工作？”

在这个问题中，Microsoft 希望看到你对技术充满热情。一个很好的回答可能是：“从我记事起，我就一直在使用 Microsoft 的软件，我对 Microsoft 如何创造出一款普遍优秀的产品印象深刻。例如，我最近一直在使用 Visual Studio 学习游戏编程，它的 APl 非常出色”。请注意，这样的答案显示了对技术的热情！

独特之处：
只有当你表现得很优秀时，才会联系到招聘经理，因此如果你能与其谈话的话，这是一个很好的迹象！

此外，Microsoft 倾向于赋予团队更多的个人控制权，并且产品集是多样化的。由于不同的团队看重不同的方面，因此 Microsoft 内不同部门的体验可能会有很大差异。

Amazon 面试
Amazon 的招聘流程通常从电话视频开始的，由一个特定的团队对候选人进行面试。在一小段时间内，候选人可能会有两次或两次以上的面试，这要么表明他们的面试官之一没有被说服，要么表明他们被考虑进入一个不同的团队或资料库。在更不寻常的情况下，例如，当一个求职者在公司当地或最近参加过另一个职位的面试时，他可能只需要做一次电话面试。

面试你的工程师通常会要求你通过共享的文档编辑器编写简单的代码。他们还会经常提出一系列的问题来探索你所熟悉的技术领域。

接下来，你要飞往西雅图（或任何你要面试的办公室），与一两个团队进行四到五次面试，这些团队根据你的简历和电话面试选择了你。首先你将必须能在白板上写代码，一些面试官还会考察其他的技能。面试官都被分配了一个特定的区域对你进行探查，而且他们之间可能看起来非常不同。在提交自己的反馈之前，他们看不到其他人的反馈，并且在招聘会议之前，他们不提倡提前对这些反馈进行讨论。

“挑刺者（bar raiser）”面试官负责保持面试的高标准。他们参加特殊的培训，并在负责面试的小组之外对候选人进行面试，以平衡小组的面试反馈。如果一场面试看起来非常困难且与众不同，那很可能就是 bar raiser。这个人在面试方面有丰富的经验，在招聘决定上也有否决权。但是请记住：仅仅因为你在本次面试中应对得很艰难，并不意味着你实际上的表现很差。你的表现是相对于其他候选人来判断的，它不是基于简单的“正确百分比”来评估的。

一旦你的面试官提交了他们的反馈，他们将开会讨论。他们将是做出招聘决定的人。

虽然 Amazon 的招聘人员通常非常善于跟进候选人，但偶尔也会出现延迟。如果你一周内还没有收到 Amazon 的邮件，我们建议你发送一封友好的电子邮件来询问。

必要的准备：
Amazon 非常注重系统的扩展。确保你为可扩展性问题做好了准备。要回答这些问题，你并不一定需要有分布式系统方面的背景。请参阅我们在系统设计和可扩展性一章中的建议。

此外，Amazon 倾向于问很多关于面向对象设计的问题。建议查看面向对象设计一章的示例问题和建议。

独特之处：
Bar Raiser 是由其他团队引进的，以保持高标准。你需要给这个人和招聘经理留下深刻的印象。

Amazon 比其他公司更倾向于在招聘过程中进行试验。这里描述的过程是典型的面试体验，但是由于 Amazon 的试验，它不一定是通用的。

Google 面试
关于 Google 面试的谣言不绝于耳，但大多数都是谣言。它的面试其实与 Microsoft 或 Amazon 的面试并没有太大不同。

一位 Google 工程师负责第一次电话面试，因此要对棘手的技术问题有个心理准备。这些问题可能涉及编码，有时需要通过共享文档进行编码。应聘者通常被要求遵守相同的标准，在电话视频面试（phone screens）上被问到的问题与现场面试（on-site）时类似。

在现场面试中，你将与四到六个面试官进行面试，其中一个是午餐面试官（lunch interviewer）。每个面试官的反馈对其他面试官是保密的，所以你可以放心，每次面试开始，面试官对你的印象都是空白的。你的午餐面试官不会提交反馈，所以这是一个问诚实问题的好机会。

面试官通常不会被限定到特定的关注点，我们也无法“结构性”地或“系统”地来回答你什么时候会被问到什么问题。每个面试官都可以按照自己的意愿进行面试。

书面反馈将提交给由工程师和经理组成的招聘委员会（HC），最终决定是录用还是不录用。面试反馈通常分为四类（分析能力、编码、经验和沟通），总分从 1.0 到 4.0。HC 通常不包括你的任何面试官。如果包括的话，那纯属偶然。

若发放 offer，HC 希望看到至少有一位面试官是“狂热的支持者（nthusiastic endorser）”。换句话说，得分分别为 3.6、3.1、3.1 和 2.6 的简历比所有得分都是 3.1 分的简历要好。

你不一定需要在每次面试中都表现出色，你的电话面试表现通常也不是影响最终决定的重要因素。

如果 HC 建议发放 offer，你的 packet 将提交给薪酬委员会，然后再提交给执行管理委员会。由于存在许多阶段和委员会，因此返回决策可能需要数周时间。

必要的准备：
作为一个基于 web 的公司，Google 关心的是如何设计一个可扩展的系统。因此，请确保你准备好了回答系统设计和可扩展性方面的问题。

不论经验如何，Google 都非常重视候选人的分析（算法）技能。即使你认为以前的经验值得考虑，你也应该为这些问题做好充分的准备。

不同之处：
你的面试官不会做出雇用决定。相反，他们会将反馈信息提交给招聘委员会。招聘委员会将给出一个决定，而 Google 高管有权回绝掉这个决定，虽然他们很少这样做。

Apple 面试
就像 Apple 公司本身一样，Apple 的面试程序也没有什么官僚作风。面试官将寻求优秀的技术技能，但是对职位和公司的热情也很重要。虽然求职者是否为 Mac 用户不是先决条件，但你至少应该熟悉这个系统。

面试过程通常从招聘人员的电话视频面试开始，了解你的基本技能，然后是一系列与团队成员进行的技术电话视频面试。

一旦你被邀请进入园区，通常会是招募人员来向你打招呼，并向你介绍整个招聘流程。然后，你将与申请的职位所在团队的成员，以及与你团队合作的关键人物，进行进行 6~8 次面试。

你需要对一对一（one-on-one）和二对一（two-on-one）的混合面试有心理预期。准备好在白板上写代码，并确保你所有的想法都清楚地传达出来。午餐是和你未来的潜在经理一起吃的，看起来比较随意，但这仍然是一次面试。每个面试官通常专注于一个不同的领域，通常不提倡与其他面试官分享反馈，除非他们想让后续面试官深入了解一些东西。

在一天结束时，你的面试官会互相交换意见。如果每个人都觉得你是一个可行的候选人，你将会和你申请的公司的主管和副总裁进行面试。虽然这个决定是非正式的，但如果你到了这一步，是一个很好的迹象。这一决定也会在幕后发生，如果你不通过，你就会被护送出大楼，而（直到现在）你也不会察觉。

如果你参加过了主管和副总裁的面试，你所有的面试官都会聚集在一个会议室里，给你一个正式的赞成（thumbs up）或反对（thumbs down）。副总裁一般不会出席，但如果他们对招聘不满意，仍然可以否决。招聘人员通常会在几天后跟进，但你可以随时联系他/她，了解最新情况。

必要的准备：
如果你知道你面试的是哪个团队，确保你仔细了解了他们的产品。你喜欢它什么？你能改进什么？提供具体的建议可以显示你对这份工作的热情。

独特之处：
Apple 经常进行二对一的面试，但是不要为此感到压力——这和一对一的面试是一样的！

此外，Apple 员工是 Apple 的铁杆粉丝。你应该在面试中表现出同样的热情。

Facebook 面试
一旦被选中参加面试，应聘者通常会进行一两个电话视频面试。电话面试将是技术性的，并且会涉及编码，通常是使用线文档编辑器。

在电话面试之后，你可能会被要求做一个家庭作业，其中包括编码和算法的混合题目。在这里注意你的编码风格。如果你从未在一个有完整代码评审（code review）的环境中工作过，那么找一个必须评审你代码的人可能是个好主意。

在现场面试中，你将主要与其他软件工程师进行面试，但只要招聘经理有空，他们也会参与进来。所有的面试官都经过了全面的面试培训，与你进行面试的人是跟你获得 offer 的几率没有联系的。

在现场面试中，每位面试官都被赋予一个“角色”，这有助于确保没有重复的问题，并且可以全面了解候选人。这些角色是：

工作经历（“绝地武士（Jedi）”）：这个面试评估你在 Facebook 的环境下取得成功的能力。你能很好地适应这种文化和价值观吗？你对什么感到兴奋？你如何应对挑战？请准备好谈论你对 Facebook 的兴趣，因为 Facebook 需要的是有激情的人。在这次面试中，你可能还会被问到一些编码问题。

编码和算法（“忍者（Ninja）”）：这些是标准编码和算法问题，就像你在本书中会发现的一样。这些问题被设计成极具有挑战性。你可以使用任何你想用的编程语言。

设计/架构（“海盗（Pirate）”）：对于后端软件工程师，你可能会被问到系统设计问题。前端或其他专业将被问及与该学科相关的设计问题。你应该开放地讨论不同的解决方案及其权衡。

通常，你需要做好进行两次“忍者”面试和一次“绝地”面试的准备。经验丰富的候选人通常也将接受一次“海盗”面试。面试结束后，面试官在互相讨论你的表现之前会提交书面反馈。这可以确保你在一次面试中的表现不会因其他面试官的反馈而产生偏见。

一旦每个人的反馈都被提交，你的面试团队和招聘经理会聚在一起，共同做出最终决定。他们达成共识，并向招聘委员会提交了最终的招聘建议。

必要的准备：
作为“精英”科技公司中最年轻的一家，Facebook 希望开发人员具有创业精神。在面试中，你应该表现出你喜欢快速构建东西。

他们想知道，你可以使用任何一种选择的语言共同构建出一个优雅的、可扩展的解决方案。了解 PHP 并不是特别重要，特别是考虑到 Facebook 还使用 C++、Python、Erlang 和其他语言做了大量后端工作。

独特之处：
Facebook “一般来说“是从整个公司层面出发来面试开发人员的，而不是为某个特定的团队。如果你被录用，你将参加一个为期六周的“训练营”，这将帮助你在庞大的代码库中不断提升。你将获得高级开发人员的指导，学习最佳实践，最终，在选择项目时，你将获得比在面试中分配到项目时更大的灵活性。

Palantir 面试
不像有些公司会进行“合并（pooled）”面试（你是从整个公司的角度被面试的，而不是针对某个特定的团队），Palantir 是为一个特定的团队进行面试的。有时候，你的申请可能会被更改到（re-routed）到另一个更合适的团队。

Palantir 的面试流程通常从两次电话面试开始。这些面试大约 30 到 45 分钟，并且主要是技术性的。希望你能介绍一些你以前的经验，并将重点放在算法相关的问题上。

你还可能需要接受一次 HackerRank 编码评估，它将评估你编写最优算法和正确代码的能力。经验不足的求职者，比如大学毕业生，特别有可能参加这样的测试。

在此之后，成功的候选人将被邀请到园区，并将接受多达五人的面试。现场面试的内容涵盖了你以前的经验、相关的领域知识、数据结构和算法，以及系统设计。

你还可能得到 Palantir 产品的演示。问一些好的问题，并展示你对公司的热情。

面试结束后，面试官会和招聘经理开会讨论面试反馈结果。

必要的准备：
Palantir看重雇佣优秀的工程师。许多求职者表示，Palantir的问题比他们在谷歌和其他顶级公司遇到的问题更难回答。这并不一定意味着获得一份工作更难（尽管确实可以）;这只是意味着面试官更喜欢更具挑战性的问题。如果你在面试 Palantir，你应该彻底了解核心数据结构和算法。然后，集中精力准备最难的算法问题。

如果你正在面试一个后端职位，也要温习一下系统设计。这是这个过程的一个重要部分。

独特之处：
编写代码是 Palantir 面试流程中的常见部分。尽管你可以使用计算机，并且可以根据需要查找资料，但不要毫无准备地走进办公室。这些问题可能极具挑战性，并且将评估算法的效率。充分的面试准备将对你有所帮助。你也可以在 HackerRank.com 网站上在线练习编程挑战。

III. 特殊情况
促使某人读这本书的原因有很多。或许是你工作经验丰富，但从未进行过此类面试。或许你是一名测试人员或 PM。或许你实际上是在使用这本书来教自己如何更好地进行面试。这些“特殊情况（special situations）”都能在本章有所收获。

有经验的候选人
有些人认为，你在本书中看到的算法类问题只适用于应届毕业生，这并不完全正确。

更有经验的工程师可能会发现面试中对算法问题的关注略有减少——但也只是略有减少。

如果一家公司向没有经验的候选人提出算法问题，他们往往也会向有经验的候选人提出。无论对错，他们都认为这些问题中展示的技能对所有开发人员都很重要。

一些面试官可能会对有经验的候选人的标准有所较低。毕竟，这些候选人已经多年没有上过算法课了。他们缺乏练习。

另一些人则对有经验的候选人提出了更高的标准，他们的理由是，更多的经验使候选人可以看到更多类型的问题。

平均而言，两种观点是平衡的。

这个规则的例外是系统设计和架构问题，以及有关于你简历的问题。通常情况下，学生不会学习太多系统架构的知识，所以只有在专业领域才能积累处理这方面问题的经验。你在此类面试问题中的表现将根据你的经验水平进行评估。然而，学生和应届毕业生仍然会被问到这些问题，他们应该做好准备，尽可能地解决这些问题。

此外，经验丰富的候选人将被要求对诸如 “你遇到的最困难的 bug 是什么？” 等问题做出更深入的、更令人印象深刻的回答。如果你经验丰富，对这些问题的回答应该可以证明这一点。

测试人员和 SDET
SDET（测试中的软件设计工程师，software design engineers in test）工作中需要编写代码，但是这些代码是用来测试功能而不是构建功能的。因此，他们必须既是出色的编码人员，又是出色的测试人员。需要双倍的准备工作！

如果你要申请 SDET 职位，请采用以下方法来进行准备：

准备核心测试问题：例如，你将如何测试一个灯泡？一支钢笔？ 一台收银机？Microsoft Word ？“测试，Testing” 一章将为你提供关于这些问题的更多背景知识。
练习编码问题：SDET 被拒绝的首要原因是编码能力不够。虽然 SDET 的编码标准通常低于传统开发人员，但是仍期望 SDET 能有较强的编码和算法能力。在准备时，一定要练习解决普通开发人员可能遇到的所有相同的编码和算法问题。
练习测试代码问题：一个非常流行的 SDET 问题格式是“编写代码以实现 X 功能”，紧接着就会被要求：“好的，现在对其进行测试。”即使问题不是特别要求这样做，你也应该问自己，“我将如何测试这个？”记住：任何问题都可能变成一个 SDET 问题！
对于测试人员来说，良好的沟通技巧也非常重要，因为你的工作需要你与许多不同的人一起工作。不要忽视 “行为问题，Behavioral Questions” 这一章的内容。

职业建议
最后，给你一个职业建议：如果你像许多候选人一样，希望通过申请 SDET 职位这种“简单”的方式进入某个公司，那你该知道的是，许多候选人发现从 SDET 职位转到开发职位非常困难。如果你计划这样做的话，请确保你的编码和算法技能非常突出，并尝试在一到两年内转换职位。否则，你可能会发现在开发面试中很难被认真对待。

永远不要让你的编程技能退化。

产品（和项目） 经理
这些 “PM” 角色在不同的公司甚至在同一公司内部都有很大的差异。例如，在 Microsoft，一些 PM 本质上可能是客户传道者（customer evangelists），扮演着与市场营销沾边的面向客户的角色。不过，在整个园区里，其他 PM 可能需要花费很多时间进行编码。后一种 PM 的职位在面试时可能会对候选人在编码上进行测试，因为这是其工作功能的重要部分。

一般来说，负责 PM 职位的面试官希望候选人能展示以下方面的技能：

处理模棱两可：这通常不是面试中最关键的部分，但你也应该知道面试官确实看重候选人这方面的能力。面试官希望看到的是，当面对一个模棱两可的情况时，你不会不知所措，也不会停滞不前。他们希望看到你能够正面处理问题：寻找新信息，优先处理最重要的部分，并以结构化的方式解决问题。这通常在面试中不会直接考察（虽然可以），但在面试问题的回答中，面试官会留意候选人这方面的特质。
以用户为中心（态度）：面试官希望看到你以用户为中心的态度。你认为每个人都会像你一样使用这个产品吗？或者，你是那种设身处地为客户着想，试图理解他们想如何使用产品的人？诸如 “为盲人设计一个闹钟” 之类的问题已经成熟，可以用来考察候选人这一方面的特质。当你听到这样的问题时，一定要问很多问题来了解用户是谁，以及他们如何使用产品。“测试，Testing ” 一章中涉及的技能与此密切相关。
以用户为中心（技术技能）：一些拥有更复杂产品的团队需要确保他们的 PM 对产品有更深刻的理解，因为在工作中很难获得这些知识。在 Android 或 Windows Phone 的团队中，可能不需要具备深入的手机技术知识（尽管这仍然是件好事），而在 Windows Security 团队中，对安全性相关知识的了解可能是必要的。希望你不会去面试一个需要特殊技能的团队，除非你至少声称自己已经拥有了必要的技能。
多级沟通：PM 需要能够与公司各个级别的人员沟通，跨越多个职位和技术技能范围。面试官希望看到你在沟通中拥有这种灵活性。这通常是通过诸如 “向祖母解释 TCP/IP” 之类的问题来直接检验的。也可能通过与你讨论先前项目的方式来评估你的沟通技巧。
对技术的热情：快乐的员工是富有生产力的员工，因此公司想要确保你会喜欢这份工作，并对你的工作内容感到兴奋。对技术的热情——最好是对公司或团队的热情——应该体现在你的回答中。你可能会被直接问到这样的问题，例如 “你为什么对微软感兴趣？”此外，面试官会在你如何谈论你以前的经历，以及你如何谈论团队的挑战时，来发现你对工作的热情。他们想看到的是，你会渴望面对工作中的挑战。
团队合作/领导力：这可能是面试中最重要的方面，而且，毫不奇怪，在工作中也是最重要的。所有的面试官都会考察你与他人合作的能力。最常见的评估方法是这样的：“请给出一个队友没有尽到自己职责的例子”。面试官希望看到你能很好地处理冲突，你能采取主动，你能理解他人，人们喜欢和你一起工作。你为行为问题做的准备工作在这里将非常重要。
以上所有方面都是 PM 需要掌握的重要技能，因此也是面试的重点领域。这些方面的权重将与该领域在实际工作中的重要性大致匹配。

开发主管和经理
开发主管职位和经理职位几乎总是需要候选人具备强大的编码技能。如果你要在工作中进行编码，请确保对代码和算法非常精通，就像开发人员一样。尤其是 Google，在编码方面对管理人员要求很高。

此外，准备接受以下各方面的技能检查：

团队合作/领导力：任何担任管理角色的人都必须既能领导他人，又能与他人共同合作。你将在这些方面接收隐式和显式的考察。显示的评估（explicit evaluation）将以询问你如何处理之前工作中的情况的形式出现，比如你与经理意见相左的时候你怎么应对。隐式的评估（implicit evaluation）以面试官观察你如何与他们互动的形式出现。如果你太自负或太被动，面试官可能会觉得你不足以担任管理职位。
优先级排序：管理人员经常会面临棘手的问题，例如如何确保团队在紧张的截止日期前完成任务。你的面试官会希望你可以适当地确定项目的优先级，从而减少处理次要工作的精力。优先级排序意味着提出正确的问题，以了解什么是关键的，什么是你可以在合理预期内完成的。
沟通：管理人员需要与他上下级的人员进行沟通，也可能与客户或其他技术水平较低的人员进行沟通。面试官希望看到你可以进行多层次的交流，而且是以一种友好和吸引人的方式进行。在某种程度上，这也是对你个性的一种评估。
“把事情做好”：也许管理者可以做的最重要的事情就是“把事情做好”。这意味着在为项目做准备和实际执行之间取得适当的平衡。你需要了解如何组织一个项目，如何激励员工，这样你才能完成团队的目标。
最终，这些方面的大部分都会回到你之前的经历和你的个性上来。一定要使用面试准备表格进行非常非常彻底的准备。

初创公司
不同初创公司的申请和面试过程相差很大。我们不能逐一介绍每一家初创公司，但我们可以提供一些一般性的建议。但是，要明白，特定的初创公司的面试流程可能与此有所不同。

申请流程
许多初创公司可能会发布招聘信息，但对于最热门的初创公司来说，通常最好的方式是通过个人推荐。这个推荐人不一定是你的密友或同事。通常情况下，只要你主动表达你的兴趣，你就能让别人拿起你的简历，看看你是否适合这份工作。

签证和工作授权
不幸的是，美国许多规模较小的初创公司无法提供工作签证。他们和你一样讨厌这个制度，但无论如何你都无法说服他们雇用你。如果你需要签证并且希望在一家初创公司工作，你最好的选择是联系一位与许多初创公司合作的专业招聘人员（他们可能对哪些初创公司会处理签证问题有更好的了解），或者把搜索重点放在更大的初创公司上。

简历筛选因素
初创公司往往希望工程师不仅聪明、会编程，而且还要能在创业环境中出色工作。理想情况下，你的简历应该显示出你的主动性。例如，你从头开始做过哪些项目？

能够“立即上手（hit the ground running）”也非常重要，他们想要那些已经了解公司语言的人。

面试过程
大公司往往主要关注你在软件开发方面的总体能力，而初创公司则通常会密切关注你的个性、技能和先前的经验。

性格契合度：性格契合度通常由你与面试官的互动方式来评估。和面试官建立一个友好的、有吸引力的对话是你获得很多工作机会的敲门砖。
技术栈：因为初创公司需要能够立即上手的人，所以他们很可能会用特定的编程语言来评估你的能力。如果你知道该创业公司使用的语言，一定要温习一下细节。
经验：初创公司可能会问你很多有关你工作经验的问题。请特别注意“行为问题”这章的内容。
除上述方面外，你在本书中看到的编码和算法问题在初创公司的面试过程中也非常常见。

收购（Acquisitions）和收购雇佣（Acquihires）
在对许多收购进行技术尽职调查（due diligence）的过程中，收购方通常会对初创公司的大部分或全部员工进行重新面试。Google、Yahoo、Facebook 和许多其他公司都将此过程作为许多收购的的标准组成部分。

哪些初创公司会经历这种情况？ 又为什么呢？
进行收购面试，的部分原因是收购方认为他们的员工必须经过这个过程才能被雇佣。他们不希望收购成为这些员工进入公司的“捷径”。而且，由于被收购的方的团队是收购的核心动力，因此他们认为评估团队的技能是很有意义的。

当然，并非所有的收购都是这样的。著名的数十亿美元收购通常不需要经过这个过程。毕竟，这些收购通常是针对用户群和社区的，而与员工甚至技术无关。这时估团队的技能就不是那么重要了。

但是，这并不像 “收购雇佣需要面试而传统收购则不需要” 那么简单。雇佣收购（即人才收购）和产品收购之间存在很大的灰色地带。许多初创公司是因其团队和技术背后的想法而被收购的。因而收购完成后，收购方可能会中止原来产品的生产，但要让团队从事非常相似的工作。

如果你的创业公司正在经历这个过程，通常你需要做好你的团队有非常类似于普通候选人的面试经历的准备（因此，非常类似于你将在本书中看到的）。

这些面试有多重要？
这些面试具有极大的重要性。它们在以下三种不同方面扮演着重要的角色：

它们可以决定收购的成败与否。这往往是一家公司无法被收购的原因。
它们决定了哪些员工可以收到加入收购方公司的 offer
它们可以影响收购价格（部分因素是加入的员工数量）。
这些面试不仅仅是走个形式。

哪些员工需要接受面试？
对于科技初创公司来说，通常所有的工程师都要经过面试，因为他们是收购的核心动力之一。

此外，销售、客户支持、产品经理以及任何其他角色可能都必须经历这个过程。

通常会将初创公司的 CEO 安排在产品经理或开发经理的职位面试中，因为这通常是与 CEO 当前职责最接近的匹配项。但是，这并不是一个绝对的规则。这取决于 CEO 目前的角色和他感兴趣的是什么。在我的一些客户中，CEO 甚至选择不进行面试，而是在收购完成后离开公司。

在面试中表现不佳的员工会怎么样？
表现不佳的员工通常不会收到加入收购方的 offer。（如果许多员工表现不佳，那么收购很可能不会成功。）

在某些情况下，出于“知识转移（knowledge transfer）”的目的，一些面试表现不佳的员工会获得合同职位。但是这些职位是临时的，预期中员工将在合同终止时离职（通常是 6 个月），尽管有时员工最终会被留下来。

在其他情况下，糟糕的表现是由于员工被安置在错误的位置上（mis-slotted）造成的。这种问题通常发生在两种情况下：

有时候，一家初创公司会把不是“传统”软件工程师的人贴上软件工程师的标签。这经常发生在数据科学家或数据库工程师身上。这些人可能在软件工程师面试中表现不佳，因为他们的实际角色涉及其他技能。

在其他情况下，CEO将一名初级软件工程师向高于其实际水平的高级职位进行“推销”。这就使这名工程师在高级职位的面试中表现不佳，因为他被要求达到不公平的高标准。

在这两种情况下，有时都会对员工进行重新面试以找到更合适的职位。（不过，其他时候，员工就没这么走运了。）

在极少数情况下，首席执行官能够推翻对一个特别优秀的员工的面试决定，即使他在面试中的表现并没有反映出有什么问题。

你“最佳”（和最差）员工可能会让你大吃一惊。
在顶级科技公司进行的问题解决（problem-solving）/算法（algorithm）面试评估的是特定技能，而这些技能可能并不完全符合他们的经理对员工的评估。

我曾与许多公司合作过，他们对面试中表现最好和最差的员工感到惊讶。在这些面试中，对专业发展还有很多需要学习的初级工程师可能会成为一个很好的问题解决者。

除非你已经按照他们的面试官的方式对他们进行了评估，否则请不要把任何人排除在外。

员工是否要面临与典型的候选人相同的标准？
本质上是的，尽管有更多的回旋余地。

大公司倾向于采取规避风险的招聘方式。如果对某人的是否录用持观望态度，他们往往倾向于不雇佣。

在收购的情况下，“保持观望（on the fence）”的员工可以由于其所在团队其他成员的出色表现而获得通过。

员工对收购/收购雇佣的消息有什么反应？
这是许多初创公司 CEO 和创始人非常关心的问题。员工会对这个过程感到不安吗？或者，如果我们让他们燃起希望，但却没有实现呢？

我从我的客户那里看到，领导层对此担心的程度超出了必要。

当然，是有一些员工对这个过程感到不安。出于种种原因，他们可能不会对加入一家大公司感到兴奋。

不过，大多数员工对这个过程持谨慎乐观的态度。他们希望收购能完成，但他们知道，这些面试的存在意味着它也有可能不会顺利完成。

收购之后团队会发生什么？
每种情况都是不同的。但是，我的大多数客户都被作为一个团队被整体保留，或者可能集成到一个现有的团队中。

你应该如何准备团队的收购面试？
收购面试的面试准备与收购方的典型面试相当相似。不同之处在于，你的公司是作为一个团队来完成此任务的，而不是根据每个员工的优点来单独挑选他们参加面试。

你们都是一伙的。

与我合作过的一些初创公司搁置了他们的“实际”工作，并让他们的团队在接下来的两到三周时间里准备面试。

显然，这不是所有公司都能做出的选择，但是，从希望收购得以进行的角度来看，这确实可以大大提高你的业绩。

你的团队应该单独学习，或两三个人一组，或者进行模拟面试。如果可能，请使用这三种方法。

有些人可能比其他人准备得少。

许多初创公司的开发人员可能只是模糊地听说过算法复杂度（big O time）、二分搜索树、广度优先搜索和其他重要概念。他们将需要一些额外的时间来准备。

没有计算机科学学位的人（或很久以前获得学位的人）应该首先专注于学习本书中讨论的核心概念，尤其是 big O time（这是最重要的一个）。一个很好的第一步是从头开始实现所有核心数据结构和算法。

如果收购对你的公司很重要，给这些人足够的时间来准备。他们会需要它。

不要等到最后一分钟。

作为一家初创公司，你可能习惯了在没有大量计划的情况下进行工作。但如果你在收购面试时还是这种态度的话，结果往往不会很好。

收购面试经常是突然出现的。一家公司的 CEO 正在与一位收购方（或几个收购方）交谈，谈话变得越来越严肃。收购方提到未来某一时刻进行面试的可能性。然后，突然间，出现了一条“本周末到”的消息。

如果你等到一个确定的面试日期，你可能就只有几天的时间来准备了。你的工程师可能没有足够的时间来学习核心的计算机科学概念并练习面试问题。

给面试官
自编写上一版以来，我了解到许多面试官正在使用 “Cracking the Coding Interview” 来学习如何进行面试。这并不是本书的真正意图，但我不妨为面试提供一些指导。

实际面试中不要问本书出现的确切问题。
首先，本书中选择这些问题是因为它们非常适合面试准备。但是一些适合面试准备的问题并不总是适合面试。例如，本书中有一些脑筋急转弯，因为有时面试官会问这类问题。如果候选人在一家喜欢这些问题的公司面试，那么练习这些问题是值得的，尽管我个人认为这些问题很糟糕。

其次，你的候选人也在读这本书。你应该不想问你的候选人哪些已经解决了的问题吧。

你可以问类似的问题，但不要只是把问题从这里拿出来。你的目标是测试他们解决问题的能力，而不是他们的记忆能力。

问中等和困难难度的问题
这些问题的目的是评估一个人解决问题的能力。当你问一些过于简单的问题时，候选人的表现就不能完全发挥。简单问题会严重影响一个人的表现。这不是一个可靠的指标。

寻找有多个障碍的问题。
有些问题会有一个“啊哈！”的时刻。它们基于一种特殊的洞察力。如果候选人没有 get 到这个点，那么他们的表现就会很差。如果他们 get 到了这点，那么他们的表现突然就会胜过许多候选人。

即使这种洞察力是技能的一个指标，它仍然只是一个指标。理想情况下，你需要一个具有一系列障碍、见解或优化的问题。多个考察点胜过一个考察点。

这里有一个测试：如果你能给一个提示或指导，使一个候选人的表现有很大的不同，那么这可能不是一个很好的面试问题。

使用困难的问题，而不是困难的知识。
有些面试官，为了把一个问题弄得很难，无意中使用到了困难的知识。果然，很少有候选人表现出色，所以统计数据看起来是正确的，但这并没有准确反映出候选人的技能水平。

你期望候选人拥有的知识应该是相当简单的数据结构和算法知识。希望计算机科学专业的毕业生了解 big O 和树的基本知识是合理的。大多数人不会记得 Dijkstra 算法，也不会记得 AVL 树是如何工作的。

如果你的面试问题需要晦涩的知识，问问自己：这真的是一项重要的技能吗？它是否做够重要，以至于我不惜减少雇佣的候选人的数量，或者减少我对候选人解决问题能力或其他技能的关注度？

你评估的每项新的技能或属性都会减少 offer 的发放数量，除非你通过放宽对另一项技能的要求来平衡这一点。当然，在候选人其他条件都相同的情况下，你可能更喜欢能背诵两英寸厚的算法教科书中详细内容的人。但是实际上候选人的其他条件是不一样的。

避免出现“吓人的”问题。
有些问题会吓到候选人，因为这些问题看起来好像涉及到了一些专业知识，即使它们实际上并没有。这通常包括以下问题：

数学或概率。
底层知识（内存分配等）。
系统设计或可扩展性。
专有系统（Google 地图等）。
例如，我有时会问的一个问题是找出 1000 以下的满足 a^3 + b^3 = c^3 + d^3的所有正整数解（第68页）。

首先，许多候选人会认为他们必须对上面这种或其他比较高级数学做一些花哨的因式分解。其实他们并不需要这么做。他们只需要了解指数、总和与相等这些概念，仅此而已。

当我问这个问题时，我明确地说，“我知道这听起来像一个数学问题。别担心。它不是。这是一个算法问题。”如果他们开始沿着因式分解的道路走下去，我会阻止他们，并提醒他们这不是一个数学问题。

其他问题可能涉及一些概率。它可能是候选人肯定知道的东西（例如，从5个选项中选择一个，从1到5中选择一个随机数），但事实上仅仅因为它包含概率就会吓到候选人。

问一些听起来吓人的问题要小心。记住，面试本身对候选人来说已经是非常紧张了。加上一个“吓人的”问题可能只会让候选人感到更加慌乱，从而导致他表现不佳。

如果你要问一个听起来“很吓人”的问题，那么你要确保让候选人放心，这个问题并不需要他们下意识以为要使用到的知识。

给予积极的心理强化。
有些面试官过于关注“正确”的问题，以至于忘了考虑自己的行为。

许多候选人被面试吓倒了，他们试着去理解面试官的每一个字。他们会抓住每一件听起来可能是积极或消极的事情不放。他们会把“祝你好运”这句话理解为某种意义，即使你对每个人都说了这句话，无论其表现如何。

你需要让候选人对面试体验、对你以及自己的表现感到满意。你要使他们感到轻松自在。一个紧张的候选人会表现得很差，但这并不意味着他们不好。此外，一个对你或公司有负面感受的优秀的候选人不太可能接受 offer——他们也可能劝阻他们的朋友不要到你这儿面试或接受 offer。

试着对候选人热情友好。可能有些人很容易做到这一点而有些人不行，但是要尽你最大的努力。

即使你不是天生热情友好的人，你也可以在整个面试过程中努力说一些积极的话：

“对，没错。”
“很好的观点。”
“做的不错。”
“是的，这是一个非常有趣的方法。”
“完美。”
不管候选人表现得有多差，总有一些事情是他们做对了的。想办法在面试中注入一些积极的因素。

深入挖掘行为问题。
你问他们一个关于工作中遇到的具有挑战性的场景的问题，他们会告诉你他们团队所面临过的困境。那从你的角度看来，这位候选人并没有做太多事情。

不过不要那么快下结论。候选人可能只是不会专注于自己，因为他们在以往的工作中都是庆祝团队的成就，而不是吹嘘自己。这在担任领导职务的人和女性候选人中尤其常见。

不要仅仅因为你理解不了一个候选人做了什么，就认为他在某种情况下没有做什么事情。（委婉地）说出情况。具体询问他们是否可以告诉你他们的角色是什么。

如果这听起来并不是真的解决了困难的问题，那么，再一次，深入探究。让他们更详细地说明他们是如何看待这个问题的，以及他们采取了哪些不同的步骤。问问他们为什么要采取某些行动。不描述自己所采取行动的细节只能说明他们是一个有瑕疵的候选人，但不一定是一个有瑕疵的员工。

成为一名优秀的面试候选人本身就是一项能力（毕竟，这也是本书存在的原因之一），而且你可能不想对这项能力进行评估。

指导你的候选人。
通读有关候选人如何开发良好算法的章节。这些建议中有很多是你可以提供给那些正在挣扎的候选人的。当你这样做时，你并不是在“教如何面试”，你只是把他们的面试能力与工作能力给分开了。

很多候选人不会用一个例子来帮助解决面试问题（或者他们不会用一个好的例子）。这大大增加了他们给出答案的难度，但这并不一定意味着他们不是很好的问题解决者。如果候选人自己没有写一个例子，或者他们无意中写了一个特殊的用例，请指导他们。
有些候选人需要很长时间才能找到 bug，因为他们使用了一个非常大的用例。这并不会使他们成为一个糟糕的测试人员或开发人员。这只是意味着他们没有意识到，先从概念上分析他们的代码会更有效，或者一个小的例子几乎可以工作得一样好。引导他们。
如果他们在找到最优解之前就开始深入研究代码，那么把他们拉回来，把注意力集中在算法上（如果这是你想看到的）。如果是因为候选人真的没有时间，就说他从未找到或实现过最优解决方案，那绝对是不公平的。
如果他们感到紧张不安，不知道下一步该怎么做时，可以建议他们先使用通过蛮力（brute force）解决的方案，再寻找可以优化的方面。
如果他们什么都没说，而且这道题有一种相当明显的蛮力解决方法时，提醒他们先从蛮力开始是没关系的。他们的第一个解决方案不一定必须是完美的。
即使你认为候选人在这些方面的能力是一个重要因素，但这并不是唯一的因素。你完全可以将某人标记为“未通过”此障碍，但同时要帮助并引导他们越过这一障碍。

虽然这本书的目的是指导候选人通过面试，但作为面试官，你的目标之一就是消除候选人没有准备对面试表现的影响。毕竟，有些候选人已经为面试做过准备，而有些则没有，但这可能并不能充分说明他们作为工程师的能力。

使用本书中的建议指导候选人（当然，要在合理的范围内——毕竟你不希望因为过多地指导候选人，以至于无法评估他们解决问题的能力）。

不过在这里要小心。如果你本身就使候选人生畏，那这种指导可能会让事情变得更糟。当你告诉候选人，他们在不断地创建错误的例子，没有优先考虑正确的测试方法，等等，这往往会把事情搞砸。

如果他们想要安静，就给他们安静。
候选人最常问我的一个问题是，当他们只需要安静地思考一会儿的时候，面试官却执意要开口说话，他们该如何应对这种情况。

如果你的候选人需要安静，那就给他时间思考。学会区分候选人的 “我被困住了，不知道该做什么” 和 “我在默默地思考” 这两种状态。

这可能会帮你来决定是否要指导你的候选人，因为你的指导可能会帮助到很多候选人，但这不一定会帮助到所有的候选人。因为有些人反而需要一点时间来自己思考。给他们时间，这样当你评估他们的时候，就要考虑到他们得到的指导比其他人少。

####了解你的模式：常规检查、质量、专家级和指代型。

在非常非常高的层次上，有四种问题模式：

常规检查：这些通常是简单的问题解决型（problem-solving）问题或设计问题。它们被用来评估候选人解决问题的最低能力。不能通过这些问题来区分候选人的能力是 “okay” 还是 “great”。你可以在面试流程早期使用这类问题（过滤掉最差的候选人），或者当你只是需要最低程度能力的候选人时也可以使用。
质量检查：这些都是更具挑战性的问题，通常在问题解决或设计中。这类问题被设计得比较严谨，真正需要候选人去思考。当算法/解决问题的技能非常重要时，使用这些技巧。在这种情况下，面试官犯的最大的错误是问一些实际上不是很好的问题解决型问题。
专家级问题：这些问题用于测试特定主题的知识，例如 Java 或机器学习。一项技能，只有当一个优秀的工程师在工作中不能快速学会时，才应该使用专业问题对其进行考察。这些问题必须确实是专家级别的问题。不幸的是，我曾经遇到过这样的情况，一家公司询问刚刚完成了为期 10 周的编程训练营的候选人有关 Java 的详细问题。这又能说明什么呢？如果她有这方面的知识，那么这也只是她最近才学到、并且轻松掌握的知识。如果这项技能很容易学会，那么就没有理由以此来决定候选人是否被雇佣。
指代型知识：这是一种不太专业的知识（事实上，你甚至可能不需要它），但是你希望与他们级别相同的候选人知道。例如，如果候选人知道CSS或HTML，这对你来说可能不是很重要。但是，如果候选人深入研究了这些技术，却不能谈论为什么表格好或不好，这就说明了一个问题。他们没有在工作中吸收核心信息。
代理知识：这不是专家级别的知识（实际上，你甚至可能不需要它），但是你希望这种级别的候选人能够了解这些。例如，如果候选人知道 CSS 或 HTML，这对你来说可能不是很重要。但是，如果候选人已经深入研究了这些技术，却不能谈论为什么 table 好或不好，这就说明了一个问题。他们没有在工作中吸收核心信息。
当一家公司面试时将这些因素混乱搭配时，就会遇到麻烦：

他们向不是专家的人询问专家问题。
当他们不需要专家时，他们却雇佣了专家。
他们需要专家，但面试却只是评估了基本技能。
他们在询问常规检查（简单）问题，却认为自己问的是质量检查问题。因此，他们对候选人的表现给出了 “okay” 或 “great” 的评价，事实上这会使候选人微小的差别被错误地放大。
实际上，在与许多大大小小的科技公司合作进行招聘时，我发现大多数公司都至少做错了其中的一件事。



第4章
面试之前 
如果想在面试中有好的表现，面试之前就应该开始准备，事实上，面试开始数年前就应该
开始准备。下面的时间表列出了你应该在什么时间准备什么内容的大纲。
如果你晚于下面列出的流程才开始准备面试，请不要担心，只需尽你所能追上下面的时间
表，并且集中精力准备面试即可。祝你好运！
4.1 积累相关经验
如果没有一份优秀的简历，就不会有面试的机会；而如果没有丰富的相关经验，就不会有
出色的简历。因此，获得面试机会的第一步即获取相关经验。越早地意识到这一点越好。
对于在校学生来说，获取相关经验则意味着你应做好以下准备。
 选择有大型课程设计的课程。你选择的课程应该有配套的需进行大量编码的课程设计，
这是在有正式工作经验之前进行实践的绝好机会。课程设计与现实生活联系越紧密越好。
 申请实习。入学之后，尽量早些寻求实习机会。在毕业之前，最初的这些实习可以成为
你寻找更好实习机会的敲门砖。很多顶尖的科技公司专门为大一和大二的学生设计了实
习项目。你还可以看看创业企业，它们也许会提供一些更灵活的机会。
 着手编程。在闲暇时间，你可以开发一个项目，参加黑客马拉松①，抑或对开源项目做
出贡献。做什么事情并没有那么重要，重要的是你要着手编程。这样做不仅会提高技术
水平，丰富实践经验，更重要的是你表现出的主动性会令公司印象深刻。
而另一方面，专业人士可能早已累积好相应资本，准备跳槽进入他们梦寐以求的公司。比
如，谷歌的开发人员可能已经拥有足够的经验，有机会跳槽到 Facebook。不过，如果你想从不
知名的小公司跳到科技巨头，或者从测试岗位转为开发人员，请参考以下这些建议。
 多承担一些编程工作。在不透露跳槽意向的前提下，你可以向经理表达自己想在编程上
接受更大挑战的意思。尽可能地参与一些重大项目，并多多使用对自己以后有利的技术，
将来它们会成为简历上的亮点。另外，简历上也要尽量多列举这些与编程相关的项目。
 善用晚上和周末的闲暇时光。如果有空闲时间，可以试着开发一些手机应用、网页应用
或者桌面软件。这样，你就有机会接触到时下流行的新技术，从而更契合科技公司的需
求。这些项目经验都可以写到简历上，没有什么比“为兴趣而工作”更能打动招聘人员
的了。
总而言之，公司最青睐的人才必须具备两大特性：一是天资聪颖，二是编程功底扎实。要
是你能在简历上充分展示这两点，面试机会就唾手可得了。
—————————— 
① hackathon，黑客马拉松，又译“编程马拉松”或“黑客松”。该概念 1999 年起源于美国 Sun 公司，在该活动当中，
软件工程师以及其他与软件开发相关人员相聚在一起，以紧密合作的形式去进行某项软件项目。——译者注



此外，你应当提前规划好职业发展路径。如果打算转型成为管理者，哪怕当下应聘的仍是
开发岗位，也需要现在就想方设法地培养自己的领导才能。
4.2 写好简历
简历筛选标准与面试标准并无太大差别，同样考核的是求职者是否聪明，能否开发程序。
这意味着你在准备简历时应该突出这两点。提到自己喜欢打网球、旅游或玩魔法牌可没
什么用。在罗列这类无关紧要的爱好之前，务请三思，宝贵的篇幅应该用来展示自己的技术
才能。
4.2.1 简历篇幅长度适中
在美国，人们会建议工作经验不足 10 年的求职者将简历压缩成 1 页；超过 10 年的，可以
使用 1.5 至 2 页篇幅。
如果你打算使用长篇幅的简历，还望三思。篇幅较短的简历通常会令人印象更为深刻。
 招聘人员浏览一份简历一般只会用 10 秒钟左右。要是你的简历言简意赅，恰到好处，
招聘人员一眼就能看到。废话连篇只会模糊重点，扰乱招聘人员的注意力。
 有些人遇上冗长的简历甚至不会阅读。你真的想冒此风险，让别人直接扔掉你的简历
吗？
如果看到这里你还在想，我工作经验太丰富了，1 至 2 页篇幅根本放不下，怎么办？相信我，
你可以的。其实，简历写得洋洋洒洒并不代表你经验丰富，反而只会显得你完全抓不住重点。
4.2.2 工作经历
简历不是也不应该是工作经历的编年史。你应该只列举那些相关的工作经验——那些会给
别人留下深刻印象的工作经验。
列举要点
在描述工作经历时，请尽量采用这样的格式：“使用 Y 实现了 X，从而达到了 Z 效果。”比
如下面这个例子：
 “通过实施分布式缓存功能减少了 75% 的对象渲染时间，从而使得用户登录速度加快
了 10%。”
下面还有一个例子，描述略有不同：
 “实现了一种新的基于 windiff 的比较算法，系统平均匹配精度由 1.2 提升至 1.5。”
尽管不是所有经历都能套用此句型，但原则无非是描述做过什么，如何完成，结果如何。
理想的做法是尽可能地量化结果。
4.2.3 项目经历
在简历中列出“项目经历”这一部分会让你看起来很专业。对于大学生和毕业不久的新人
尤其如此。
简历上应该只列举 2 到 4 个最重要的项目。描述项目要简明扼要，比如使用哪些语言或技
术。你也可以加上一些细节，比如该项目是个人独立开发还是团队合作的成果，是某一门课程
的一部分还是独立开发的。当然，除非能让简历更出彩，否则这些细节不一定放到简历上。独


立项目一般说来比课程设计会更加出彩，因为这些项目会展现出你的主动性。
项目也不要列太多。很多求职者都犯过这样的错误，在简历上一股脑儿列出先前做过的 13
个项目，鱼龙混杂，效果反而不佳。
那么，应该列出哪些项目呢？说实在的，其实这并没有那么重要。有一些公司非常喜欢开
源项目（参与这些项目说明具备了大型代码库开发的经验），另一些公司则更喜欢独立项目（了
解你在这些项目中的贡献会更加容易）。你的项目可以是一款移动应用、网络应用或者任何东西。
最重要的是，你确实参与了开发。
4.2.4 软件和编程语言
4.2.4.1 软件
对于列出何种软件应该保守一些，并且你需要了解对于目标求职公司来说，列出哪些软件
是合适的。几乎在所有情况下，微软 Office 之类的软件不应列在简历中。类似于 Visual Studio
和 Eclipse 之类的技术软件相对有用一些，但是很多顶尖科技公司对这些软件并不关心。毕竟学
习 Visual Studio 不是很难。
当然，列出这些软件也并没有坏处。这样做只是占用了简历上宝贵的空间。你要权衡这其
中的利弊。
4.2.4.2 编程语言
你是否需要列出所有你使用过的语言？还是只列出你顺手的那些？
列出所有你使用过的语言有危险。很多面试官在面试中会认为你对简历上所列出的任何内
容都相对熟悉。
另外一种策略是列出你用过的主要语言，后面加上熟练程度，比如像下面这样的。
 编程语言：Java（非常熟练），C++（熟练），JavaScript（有过使用经验）。
你可以使用任何可以有效描述你的技能的形容词，比如“非常熟练”“使用流畅”等。
也有一些求职者会列出使用某种特定语言的年限，但是这会令人困惑。如果你 10 年前学习
了 Java 并在随后的几年偶尔使用它，那么你对于 Java 的使用年限是多少年呢？
正因如此，在简历中，年限并不是一个很好的表述方式。更好的方法是使用简单的文字表
达你的意思。
4.2.5 给母语为非英语的人及国际人士的建议
一些公司可能会因为小小的笔误就扔掉你的简历，所以请至少找一位以英语为母语的人来
帮你审校简历。
此外，申请美国的工作时，简历中不要包含年龄、婚姻状况或国籍等。公司并不想看到这
些个人信息，因为怕惹上不必要的麻烦。
4.2.6 提防（潜在的）污名
一些编程语言存在污名。有时这些污名源于编程语言本身，但是更多情况下是由该编程语
言使用的场景所致。我并不是在为这些污名辩护，我只是想让你意识到这些污名的存在。
你应该注意的污名有以下几点。


企业级编程语言。一些编程语言存在污名，主要是因为它们用于企业级开发。Visual Basic
就是一个很好的例子。如果你表现出对于 VB 非常熟练，那别人就会认为你没有什么技
术实力。很多人都认可 VB.NET 确实可以用于开发非常复杂的应用程序，但是它所开发
的应用程序并不是十分复杂。没有哪个知名的硅谷公司使用 VB。
事实上，整个.NET 平台都面临着同样的问题（虽然没有那么严重）。你如果主要专注于.NET
但是并不是申请.NET 的职位，那么与有着不同背景的求职者相比，你需要更努力地展示你技术
方面的实力。
 过于专注于编程语言。当顶尖科技公司的招聘人员看到简历中列出了所有 Java 语言的版
本时，他们会对求职者的能力有负面印象。很多不同圈子的人都相信最好的软件工程师
并不把自己禁锢在一种特定的编程语言上。因此，当招聘人员看到某个求职者似乎在炫
耀知道一种编程语言的某个特定版本时，他们通常会认为这位求职者“不是我们需要的
那类人”。
请注意，这并不是说你必须要把标榜编程语言的内容都从简历中移除。你需要理解招聘公
司看重什么。一些公司确实非常注重这些技能。
 资质证书。对于软件工程师来说，资质证书可以带来正面影响、中性影响或是负面影响。
这和过于专注于编程语言是一样的道理。如果一个公司对于列出大量技术的求职者有偏
见，那么它对于列出大量资质证书的行为也很可能存在偏见。这意味着，在一些情况下，
简历中不要出现资质证书。
 只会 1 至 2 种编程语言。编程时间越多，开发的项目越多，用的编程语言就越多。当招
聘人员看到简历中只列出一种编程语言时，他们就会认为你没有很多解决问题的经验。
他们也会担心只学过 1 至 2 种编程语言的求职者会在学习新技术时遇到困难，（为什么
这位求职者没有学习更多的技术?）或者他们会认为求职者过于依赖于某种特定的技术
（有可能并没有使用最适合当前任务的编程语言）。
这条建议并不是要帮助你修改简历，而是要帮助你获取有用的经验。如果你的专长是
C#.NET，那么试着使用 Python 或者 JavaScript 开发一些项目。如果你只会使用 1 至 2 种编程语
言，那么请用其他语言开发一些应用程序。
尽可能让自己的经验多样化。Python、Ruby 和 JavaScript 这 3 种语言就显得过于相似，最
好可以学习一些更加差异化的编程语言，比如 Python、C++和 Java。
4.3 准备流程图
下面的流程图很好地解释了如何准备面试。重要的是，面试准备并不仅仅是准备面试问题。
做项目和写代码同样重要！



第5章
行为面试题 
面试官通过行为面试题来看看你的个性，更深入地了解你的履历，同时缓和面试的紧张气
氛。这类面试题很重要，只有事先准备，才能真正做到有的放矢。
5.1 面试准备清单
逐字逐句检查简历，确保回答每个部分或项目时都能对答如流。填写下面的表格，它会助
你一臂之力。
常见问题 项目 1 项目 2 项目 3 
遇到过的挑战
遭遇过的滑铁卢
最享受什么
如何体现领导力
如何处理冲突
有哪些可改进之处
可以在表头中列出在简历中提到的主要事项，比如项目、职位或活动。然后在每一行写清
楚常见问题。
在面试前温习这个表格。为了方便掌握和记忆，可以把每个故事提炼为几个关键词。这样，
就可以在面试时胸有成竹、从容不迫了。
另外，确保你有 1 至 3 个项目可以拿得出手，并能就其细节侃侃而谈。你应该是这些项目
的主力，并且有能力同面试官深入探讨相关的技术细节。
5.1.1 你有哪些缺点
在问及自己有哪些缺点时，要说出具体缺点！像“我最大的缺点就是工作太努力了”这样
的回答，反而会显得你傲慢自大，并且不愿正视自己的不足。因此，你应该提到真实、合乎情
理的缺点，然后话锋一转，强调自己是如何克服这个缺点的。
举例如下。
“有时候，我对细节不够重视。好的一面是我反应迅速，执行力强，但不免会因为
粗心大意而犯错。有鉴于此，我总是会找其他同事帮忙检查自己的工作，确保不出问题。”
5.1.2 你应该问面试官哪些问题
大多数面试官都会给你提问的机会。有意无意间，提问的质量会成为面试官的一个评估因



素。所以，请事先准备好问题。
可以从以下 3 个方面来着手。
5.1.2.1 真实的问题
真实的问题就是你真的想知道答案的问题。下面是对多数求职者有用的一些问题点。
(1)“整个团队中，测试人员、开发人员和项目经理的比例是多少？他们是如何互动的？团
队怎么做项目规划？”
(2)“你为什么来这个公司？你遇到过的最大的挑战是什么？”
这些问题有助于你了解公司的日常工作情况。
5.1.2.2 有见地的问题
有见地的问题可以充分反映出你的知识水平和技术功底。
(1)“我注意到你们使用了 X 技术，请问你们是如何处理 Y 问题的？”
(2)“为什么你们的产品选择使用 X 协议而不是 Y 协议？据我所知，虽然 X 有 A、B、C 等
几大好处，但因为存在 D 问题，很多公司并未采用该协议。”
只有事先对该公司做过充分调研，才问得出这类有深度的问题。
5.1.2.3 富有激情的问题
富有激情的问题旨在展示你对技术的热忱。要让面试官知道你热衷学习，将来能为公司的
发展做出巨大贡献。
(1)“我对可扩展性很感兴趣，想要了解更多。有哪些机会可以学习这方面的知识？”
(2)“我对 X 技术不是太熟悉，不过听上去是个不错的解决方案。您能给我多讲讲它的工作
原理吗？”
5.2 掌握项目所用的技术
你应该主攻两三个项目，熟练掌握其中涉及的技术，使之成为你的王牌。理想的项目符合
如下标准。
 有挑战性（不仅仅让你学到很多）。
 你是主力（最好负责具有挑战性的部分）。
 你能畅谈技术部分。
你应当能够畅谈在王牌项目及其余项目中遇到的挑战、犯的错误、做出的技术决策、技术
选型中的取舍以及本可以做得更好的地方。
你也可以想想后续的问题，例如如何扩展应用。
5.3 如何应对
行为面试题可以让面试官更加深入地了解你和你的职业生涯。回答这类问题时，切记以下
建议。
5.3.1 力求具体，切忌自大
骄傲自大是面试大忌。可是，你又想给面试官留下深刻的印象。那么，怎样才能很好地秀
出自己的实力而又不显得自大呢？那就是回答问题要具体！



具体也就是只陈述事实，剩下的留给面试官自己去解读。例如，相比于干巴巴地说“我做
了所有最难的工作”，不如就其具体工作展开描述。
5.3.2 省略细枝末节
当求职者就某个问题喋喋不休时，不熟悉该主题或项目的面试官往往听得一头雾水。
所以，请省略细枝末节，只谈重点。尽可能地解释它，至少也要说明效果。这样，你总能
给面试官留下深入探讨问题的机会。
“在研究最常见的用户行为并应用 Rabin-Karp 算法后，我设计了一种新算法，可
以在 90% 的情况下将搜索操作的时间复杂度由 Ο(n)降至 Ο(log n)。您要是感兴趣的话，
我可以详细说明。”
该回答言简意赅，重点突出，要是面试官对实现细节感兴趣，他会主动询问。
5.3.3 多谈自己
面试本质上是对个人的评估。但很多求职者（尤其是应聘领导岗位的求职者）在面试时，
把“我们”“团队”挂在嘴边。面试结束时，面试官甚至不知道求职者实际的工作贡献，这会给
面试官留下“此人过去工作贡献太少”的印象。
留心自己的回答，看看你常挂在嘴边的是“我们”还是“我”。你可以认为每个问题都是针
对你个人的，说出你做的事就好。
5.3.4 回答条理清晰
回答行为面试题有两种常见的组织方式：主题先行法与 S.A.R.法。你可以分别或组合使用
这两种技巧。
5.3.4.1 主题先行法
主题先行法即开门见山，直奔主题，回答简洁明了。
以下是一个例子。
 面试官：“给我举个例子，讲一讲你如何说服一群人做出重大改变。”
 求职者：“好的，我在学校提出过一个让本科生授课的想法，并成功说服学校采纳该建
议。起初，学校规定……”
主题先行法可以快速抓住面试官的注意力，让他了解事情梗概。这也有助于你不偏离主题，
因为你早已开门见山地点明主旨。
5.3.4.2 S.A.R.法
S.A.R.法是指先描述情景（situation），然后解释你采取的行动（action），最后陈述结果
（result）。
示例：“说说你如何与‘刺头’队友相处。”  情景。在某个操作系统项目中，安排我与其他三个人合作。其中两人都很卖力，但另外
一个人做得不多。他在开会时总是沉默寡言，也极少参与邮件讨论，只是很吃力地完成
分配给他的模块。这是一个很棘手的问题，因为我们不仅要承担更多的工作，而且不知
道能否指望他。


行动。因为不想一开始就完全否定他，所以我试着打破僵局。为此，我做了以下三件事。
首先，我想弄清楚他为什么会那样。是天性懒惰吗？是因为忙于别的事吗？我和他聊了
聊他对项目的看法。令人惊讶的是，他冷不丁地说想要做书面记录模块，要知道那是整
个项目中最耗时的部分之一。这让我意识到我错怪他了，他不是懒惰，而是因为他觉得
自己的编程水平还不够好。
弄清楚原因以后，我努力让他明白一件事：他不应该害怕搞砸项目。我告诉他我曾犯过
一些更大的错误，还提到其实我对项目的很多部分也不甚了解。
最后，我请他帮我解决这个项目的某个部分。我们坐下来，一起为一个大的组件设计了
详尽的规范，细节之多远超以往。一旦他能看到项目所有的细节，就会知道这个项目不
像他想的那样可怕。
 结果。随着信心增强，他主动承担了一系列较小的编程任务，最终参与开发了项目的最
大模块。他按时完成了分配给他的所有任务，参加讨论也更积极。后来在另一个项目中，
我和他合作得非常愉快。
切记：描述情景与结果务必言简意赅。面试官一般不需要太多细节就知道来龙去脉。实际
上，细节过多反而会令面试官摸不着头脑。
采用 S.A.R.法简明扼要地描述情景、行动和结果，可以让面试官快速了解你在项目中的作
用和重要性。
试着根据自己的故事把主题、情景、行动、结果和彰显的品质填入下表。
主 题 情 景 行 动 结 果 彰显的品质
故事 1 1. ……
2. ……
3. ……
故事 2 
5.3.5 行动是关键
一般情况下，“行动”部分是故事的重点。遗憾的是，太多人在描述情景时口若悬河，对自
己的行动却一带而过。
你应该重点谈行动，并且尽量分成几步阐述，例如：“我做了三件事。首先，我……”这样
的描述更清晰。
5.3.6 故事的意义
重读 5.3.4.2 节中的故事。它彰显了面试者什么样的品质？
 主动性、领导才能：求职者直面困境，尽力去解决它。
 同理心：求职者尝试理解队友，与缺乏安全感的队友产生共鸣，懂得队友需要什么。
 同情心：虽然队友的举动不利于团队，但求职者富有同情心，不仅不怪他，反而同情
队友。
 谦虚：求职者勇于承认错误（不管是在团队中还是在面试中）。
 团队合作、乐于助人：求职者与队友一起分担工作。
应该从以上角度想想你自己的故事，分析你的应对方式以及你的行为体现了哪些品质。

很多时候，答案是“一个都没有”。这说明你得换种更能突出你品质的方式来描述这个故事。
当然不能直说“我做了 X 这件事，因为我有同理心”，但你可以间接表达出来，举例如下。
 委婉一些：“我打电话告诉客户发生了什么事。”
 更直接地表达（同理心和勇气）：“我亲自给客户打了电话，因为我知道他直接从我这里
听到会很开心。”
如果始终无法通过描述表现出自己的某些品质，也许你该换个故事讲讲。





VI. Big O
这是一个非常重要的概念，我们为此专门写了整整一章。

Big O time 是我们用来描述算法效率的语言和指标。在开发算法时，如果不能完全理解它可能会对你造成严重的伤害。你不仅可能因为没有真正理解 big O 而受到严厉地批评，而且也很难判断你的算法是变快了还是变慢了。

掌握这个概念。

一个类比
想象一下这样的场景：你的硬盘上有一个文件，需要把它发送给住在全国各地的朋友。你需要尽快将文件发送给你的朋友。你应该如何发送？

大多数人首先想到的是电子邮件、FTP或其他电子传输方式。这种想法是合理的，但只对了一半。

如果它是一个小文件，你当然是对的。到机场搭乘飞机，然后把它送到你的朋友那里，要花 5 到 10 个小时。

但是如果文件非常非常大呢？通过飞机运送是不是可能会更快呢？

实际上，是的。一个 1TB 的文件通过电子方式传输可能需要一天以上的时间。但如果让它通过飞机运送到全国，速度会快得多。如果你的文件很紧急（而且成本不是问题），你可能只想这么做。

如果没有航班，你不得不开车穿越整个国家呢？即使这样，对于一个非常大的文件，开车运送的速度也是较快的。

时间复杂度
这就是渐近运行时（asymptotic runtime）概念，或者说 big O time，的含义。我们可以将数据传输“算法”运行时描述为：

电子传输：O(s)，其中 s 为文件大小。这意味着传输文件的时间随文件的大小线性增加。(是的，这有点简化了，但是就当前的问题而言是可以接受的。)

飞机传输：O(1)，即使是考虑了文件的大小。随着文件大小的增加，将文件发送给你的朋友将不会花费更多的时间。时间是一个常数。

不管常数有多大，线性增长有多慢，线性增长总会在某个点上超过常数。


除此之外，还有更多的运行时。最常见的有 O(log N)、O(N log N)、O(N)、O(N^2) 和 O(2^N)。但是，没有一个固定的内容为可能的运行时的列表。
你还可以在运行时中包含多个变量。例如，粉刷一个 w 米宽 h 米高的栅栏的时间可以被描述为 O(wh)。如果你需要刷 p 层油漆，那么你可以说时间是 O(whp)。

Big O、Big Theta 和 Big Omega
如果你从来没有在学术场合讨论过大O，你可以跳过这一小节。因为它更可能的是会让你感到困惑，而不是有所帮助。这个“供参考（FYI）”主要是为那些以前学过big O的人消除在措辞上的歧义，这样他们就不会说，“但是我以为 big O 的意思是……”

x学术上使用 big O, big Θ (theta), and big Ω (omega) 来描述运行时。

O (big O)：在学术界，big O 表示时间的上限。打印数组中所有值的算法可以被描述为 O(N)，但也可以被描述为 O(N^2)、O(N^3) 或 O(2^N)（或许多其他的 big O time）。这个算法至少和这些 big O time 中任意一个一样快，因此说它们是运行时的上限。这类似于一种“小于或等于”的关系。如果 Bob 是 X 岁（我假设没有人超过130岁），那么你可以说 X <= 130。说 X <= 1,000 或 X <= 1,000,000 也将是正确的。因为在技术上，这都为真（尽管不是特别有用）。同样，打印数组中的值的简单算法的运行时是 O(N)，也可以是 O(N^3) 或任何大于 O(N) 的运行时。

Ω (big omega)： 在学术界，Ω是对等的概念，但是适用于下限。打印数组中的值是Ω(N)，也可以是 Ω(log N) 和 Ω(1)。毕竟，你知道它不会比那些运行时快。

Θ (big theta)： 在学术界，Θ 同时表示 O 和 Ω。也就是说，如果算法既是 O(N) 又是 Ω(N)，则算法为 Θ(N)。Θ 给出了严格限制的运行时。

在行业中（因此也是在面试中），人们似乎将 Θ 和 O 合并在一起。big O 的行业含义更接近于学术界所说的 Θ，因为将打印数组描述为 O(N^2) 被认为是不正确的。行业上只会说这是 O(N)。

在本书中，我们将以业界倾向于使用的方式使用 big O：始终尝试提供运行时最精确的描述。

最佳情况，最坏情况和预期情况
实际上，我们可以用三种不同的方式描述算法的运行时。

让我们从快速排序的角度来看一下。快速排序选择一个随机元素作为“基准（pivot）”，然后交换数组中的值，以使小于基准的元素出现在大于基准的元素之前。这给出了“部分排序”，然后使用类似的过程递归地对左右两边排序。

最佳情况：如果所有元素都相等，那么快速排序平均将只遍历数组一次。这是 O(N)。（这实际上在某种程度上取决于快速排序的实现。但是，有些实现将在有序数组上非常快地运行。）

最坏的情况：如果我们真的很不幸，选取的基准屡次是数组中的最大元素，该怎么办？ （实际上，这很容易发生。如果选择子数组中的第一个元素为基准，并且以相反的顺序对数组进行排序，就会遇到这种情况。）在这种情况下，我们的递归不会将数组分成两半，而是在每一半上递归。它只是将子数组缩小了一个元素。这将退化为O(N^2) 运行时。

预期情况：尽管如此，通常这些完美或糟糕的情况不会发生。当然，有时基准会非常低或非常高，但不会一次又一次地发生。我们可以期望运行时间为 O(N log N)。

我们很少讨论最佳情况下的时间复杂度，因为这不是一个非常有用的概念。毕竟，我们可以用任何算法，在特殊情况下的一些输入，然后在最佳情况下得到 O(1) 的时间。

对于大多数算法，最坏情况和期望情况是相同的。但是，有时它们是不同的，我们需要描述这两种运行时。

最佳/最差/预期情况与 big O/theta/omega 之间有什么关系？

候选人很容易混淆这些概念（可能是因为两者都有“较高”，“较低”和“完全正确”的概念），但是这些概念之间没有特定的关系。

最佳，最差和预期情况描述了特定输入或场景的 big O（或 big theta）时间。

Big O、big omega 和 big theta 描述了运行时的上限，下限和严格范围。

空间复杂度
时间不是算法中唯一重要的东西。我们还可能关心算法所需的内存或空间。

空间复杂度是一个与时间复杂度平行的概念。如果我们需要创建一个大小为 n 的数组，这将需要 O(n) 空间。如果我们需要一个大小为 n x n 的二维数组，则将需要 O(n^2) 空间。

递归调用中的堆栈空间也很重要。例如，这样的代码将占用 O(n) 时间和 O(n) 空间。

int sun(int n){
	if(n<=0){
		return 0;
	}
	return n+sum(n-1)	
}

每个调用都会向堆栈添加一层。

1 sum(4)
2 	-> sum(3)
3 		-> sum(2)
4 			-> sum(1)
5 				-> sum(0)
每个调用都被添加到调用堆栈，并占用实际内存。

但是，仅仅因为你总共有 n 次调用并不意味着它占用了 O(n) 空间。考虑下面的函数，它将 0 到 n 内相邻元素的相加：

int pairSumSequence(int n){
	int sum=0;
	for(int i=0;i<n;i++){
		sum+=pairsum(i,i+1);
	}
	return sum;

int pairSumSequence(int n){
	return a+b;
}

对 pairSum 大约会有 O(n) 次调用。但是，这些调用不会同时存在于调用堆栈中，因此你只需要 O(1) 空间。

删除常量
对于特定的输入，o（n）可能比o—1更快。big o只是表示增长率。
因此，我们删除了运行时中常量。一个可能是o-2n算法用o-n表示。
许多人拒绝这么做，他们看到了两个非嵌套的for循环，会坚持认为这是o2n，它们认为更精确，其实不是。

考虑下面代码：

Min and Max 1
int min=Integer.MAX_VALUE;
int max=Integer.MIN_VALUE;
for(int x:array){
	if(x<min) min=x;
	if(x>max) max=x;
}

Min and Max 2
int min=Integer.MAX_VALUE;
int max=Integer.MIN_VALUE;

for(int x:array){
	if(x<min) min=x;
}
for(int x:array){
	if(x>max) max=x;
}

which更快？第一个执行一个for循环，另一个执行两个for循环。但是第一个方案有两行代码，而不是一行。如果你要计算指令的数量，那么你必须到汇编层，考虑乘法比加法需要更多的指令，编译器将如何优化某些内容以及各种其他细节。

这将是极其复杂的事情，所以甚至不要走这条路。big o使我们能够表达运行时如何扩展。我们只需要明白，并不意味着o-n总是比o-n^2好。

删除非主导项
如何处理o(n^2)这样的表达式？第二个N并不是一个常数，但它并不特别重要。

我们已经说过删掉常数。因此，o（n*n+n^2)就是o（n平方）。如果我们不关心后面的n平方，为什么要关心n呢？所以实际上我们没有。

你应该删除非主导项。
O(N^2 + N) 变成 O(N^2)。
O(N + log N) 变成 O(N)。
O(5*2^N + 1000N^100) 变成 O(2^N)。

我们可能在运行时表达式中仍保留一个和式。例如，表达式o（b*b+a）不能被简化。没有关于a和b特殊说明时。


6.6 多项式算法：加与乘
假设你有一个算法，它有两个步骤。什么时候运行相乘，什么时候将它们相加？
这是使候选人困惑的一个常见的原因。

add the runtimes:o(a+b)

for(int a:arrA){
	print(a);
}
for(int b:arrB){
	print(b);
}

multiply the runtime: o(A*b)
for(int a:arrA){
	for(int b:arrB){
		print(a+","+b);
	}	
}

在后一个的示例中，我们对 A 中的每个元素执行 B 代码块的操作，因此总工作量为 O(A * B)。

换一种说法：

如果你的算法是这样的形式：“执行这个操作，然后，当你完成了，执行那个操作”，那么你需要将运行时相加。

如果你的算法是这样的形式：“每次执行那个操作时，执行这个操作”，那么你需要将运行时相乘。

在面试中很容易把这个搞砸，所以要小心。


6.7 分摊时间
一个ArrayList，或者一个动态调整大小的数组，允许你在拥有大小灵活性的同时享受数组的好处。你不会耗尽 Arraylist 中的空间，因为它的容量会随着你插入元素而增长。

Arraylist 是用数组实现的。当数组达到容量限制时，Arraylist 类将创建一个容量加倍的新数组，并将所有元素复制到新数组。

如何描述插入的运行时间？这是一个棘手的问题。

数组可能是满的。如果数组包含 N 个元素，那么插入一个新元素将花费 O(N) 时间。你将不得不创建一个大小为 2N 的新数组，然后复制 N 个元素。因此该插入时间复杂度为 O(N)。

然而，我们也知道这并不经常发生。绝大多数的插入都在 O(1) 时间内进行。

我们需要一个兼顾两者的概念。这就是平摊时间（amortized time）的作用。我们得承认，确实，最坏的情况偶尔就会发生一次。但是一旦它发生了，它在很长一段时间内就不会再发生，所以其代价就被“平摊”了。

在这种情况下，平摊时间是多少？

插入元素时，我们将在数组大小为 2 的幂时将容量翻倍。即，在 插入 X 个元素之后，我们分别在数组大小为 1, 2, 4, 8, 16, ..., X 时，对容量进行了翻倍。每次翻倍分别需要 1, 2, 4, 8, 16, 32, 64, ..., X 次复制。

1 + 2 + 4 + 8 + 16 + ... + X 的总和是多少？如果你从左到右读这个和式，会发现它从1开始加倍，直到达到 X。如果你从右到左读，它从 X 开始，然后减半，直到 1。

那么 X + X / 2 + X / 4 + X / 8 + ... + 1 的总和是多少？ 这大约是 2X。

因此，X 次插入需要 O(2X) 的时间。每次插入的平摊时间是 O(1)。


6.8 Log N 运行时间
我们通常在运行时中看到 O(log N)。这是怎么来的？

让我们以二分查找为例。在二分查找中，我们要在一个 N 个元素的有序数组中查找元素 x。首先我们将 x 与数组的中点进行比较。如果 x == middle，则直接 return。如果 x < middle，则在数组的左侧搜索。如果 x > middle，则我们在数组的右侧搜索。

search 9 within {1, 5, 8, 9, 11, 13, 15, 19, 21} 
	compare 9 to 11 -> smaller.
	search 9 within {1, 5, 8, 9, 11}
		compare 9 to 8 -> bigger
		search 9 within {9, 11}
			compare 9 to 9
			return


N = 16
N = 8 	/* divide by 2 */ 
N = 4 	/* divide by 2 */ 
N = 2 	/* divide by 2 */ 
N = 1 	/* divide by 2 */ 
我们可以反过来看（从 1到 16 而不是 16 到 1）。将 1 乘以多少次 2 才能得到 N？

N = 1 
N = 2 	/* multiply by 2 */
N = 4 	/* multiply by 2 */
N = 8 	/* multiply by 2 */
N = 16 	/* multiply by 2 */
表达式 2 ^ k = N 中的 k 是多少？ 这正是 log 所表达的。

2^4 = 16 -> log₂16 = 4
log₂N = k -> 2^k = N
这是一个很好的技巧。当你看到一个问题时，如果问题空间（problem space）中的元素数量每次减半，那么运行时可能就是 O(log N)。

这也是为什么在平衡二叉搜索树中找到一个元素的时间是 O(log N) 的原因。每次比较时，我们都向左或向右移动。每边有一半的节点，所以我们每次将问题空间减半。

log 的底是多少？问得好！简短的回答是，对于 big O 而言，这无关紧要。较长的解释可以在 630 页的 “Bases of Logs” 中找到。

6.9 递归的运行时间
这是一个棘手的问题。这段代码的运行时间是多少？

int f(int n){
	if(n<=1){
		return 1;
	}
	return f(n-1)+f(n-1);
}

很多人因为看到对f的两次调用，然后跳到o（n平方）这是完全错误的。

与其假设不如遍历代码，假设我们调用f4，这个函数调用2次f3，f3调用2次f2，f2调用2次f1.

这个树上多少次调用？
该数的深度为N，每个节点都有两个子节点，因为每一次是上一层的两倍。

因此，将有2 ^ 0 + 2 ^ 1 + 2 ^ 2 + 2 ^ 3 + 2 ^ 4 + ... + 2 ^ N（即2 ^（N + 1）-1）个节点。（请参阅第630页上的“ 2的幂的和”。）
尝试记住这种模式。当你有一个进行多次调用的递归函数时，运行时通常（但不总是）看起来像 O(branches^depth)，其中 branch 是每个递归调用分支的次数。在这种情况下，我们得到O(2^N)。

你可能还记得，对于 big O 而言，log 的底数并不重要，因为不同底数的 log 仅相差一个常数。但是，这不适用于指数。指数的基数很重要。比较 2^n 和 8^n。展开 8^n，得到 (2^3)^n，等于 2^3n，等于 2^2n * 2^n。可以看到，8^n和 2^n 相差 2^2n。这不是一个常数！

该算法的空间复杂度为 O(N)。虽然树中总共有 O(2^N) 个节点，但在任何给定时间只有 O(N) 个节点存在。因此，我们只需要 O(N) 可用的内存即可。


例子和练习
Big O time 刚开始的确是一个困难的概念。然而，一旦你“通窍”了，它就变得相当容易。相同的模式一遍又一遍地出现，而且其他的你也可以推导出来。

我们将从简单的开始，逐步加大难度。

示例 1
以下代码的运行时间是多少？

void foo(int[] array){
	int sum=0;
	int product=1;
	for(int i=0;i<array.length;i++){
		sum+=array[i];
	}
	for (int i=0;i<array.length;i++){
		product*=array[i];
	}
}

这将花费o-n时间，我们便利数组两次并不重要。

示例 2
以下代码的运行时间是多少？

void printPairs(int[] array){
	for(int i=0;i<array.length;i++){
		for(j=0;i<array.length;j++){
			System.out.println(array[i]+","+array[j]);
		}
	}
}

内部的 for 循环有 O(N) 次迭代，它被调用 N 次。因此，运行时间是 O(N^2)。

另一种方法是检查代码的“含义”。它正在打印所有的对（两个 元素序列）。有 O(N^2) 对，因此，运行时间是 O(N^2)。

示例 3
这与上面的示例非常相似，但是现在内部的 for 循环从 i + 1 开始。


void printPairs(int[] array){
	for(int i=0;i<array.length;i++){
		for(j=i+1;i<array.length;j++){
			System.out.println(array[i]+","+array[j]);
		}
	}
}


for 循环是非常经典的模式。了解并深入理解它的运行时间非常必要。不能只是
记住常见的运行时间，更重要的是要深入理解它们。
6.10.3.1 迭代次数
第一次通过 j 时走了 N  1 步，第二次走了 N  2 步，然后走了 N  3 步，以此类推。因此，
总步数为：(N  1) + (N  2) + (N  3) + … + 2 + 1 = 1 + 2 + 3 + … + N  1 = 1 到 N  1 的和。它的
值是 N(N + 1) / 2（参考第 13 章），因此运行时间为 Ο(N2)。
6.10.3.2 代码意义
或者，可以通过思考代码的“意义”来计算运行时间。它迭代了每一对(i, j)，并且 j 比 i 大。
共 N2对。可以粗略地认为其中一半 i < j，另一半 i > j。代码遍历对，因此它相当于 Ο(N2)。
6.10.3.3 想象它
下面是 N = 8 时迭代(i, j)的对：
(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) 
 (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) 
 (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) 
 (3, 4) (3, 5) (3, 6) (3, 7) 
 (4, 5) (4, 6) (4, 7) 
 (5, 6) (5, 7) 
 (6, 7)for 循环是非常经典的模式。了解并深入理解它的运行时间非常必要。不能只是
记住常见的运行时间，更重要的是要深入理解它们。
6.10.3.1 迭代次数
第一次通过 j 时走了 N  1 步，第二次走了 N  2 步，然后走了 N  3 步，以此类推。因此，
总步数为：(N  1) + (N  2) + (N  3) + … + 2 + 1 = 1 + 2 + 3 + … + N  1 = 1 到 N  1 的和。它的
值是 N(N + 1) / 2（参考第 13 章），因此运行时间为 Ο(N2)。
6.10.3.2 代码意义
或者，可以通过思考代码的“意义”来计算运行时间。它迭代了每一对(i, j)，并且 j 比 i 大。
共 N2对。可以粗略地认为其中一半 i < j，另一半 i > j。代码遍历对，因此它相当于 Ο(N2)。
6.10.3.3 想象它
下面是 N = 8 时迭代(i, j)的对：
(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) 
 (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) 
 (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) 
 (3, 4) (3, 5) (3, 6) (3, 7) 
 (4, 5) (4, 6) (4, 7) 
 (5, 6) (5, 7) 
 (6, 7)



这看起来像是 NxN 矩阵的一半，其大小（大约）为 N^2/2。因此，它需要 O(N^2) 的时间。

平均工作时间

我们知道外层循环运行 N 次。内层循环运行多少次？它随迭代而变化，但我们可以考虑平均迭代。

1, 2, 3, 4, 5, 6, 7, 8, 9, 10 的平均值是多少？平均值在中间，大概是 5。(当然，我们可以给出更精确的答案，但对于 big O 而言，不需要这么做。)

那对于 1, 2, 3, ... , N 呢？这个序列的平均值是 N/2。

因此，由于内层循环平均执行 N/2 次工作并且运行 N 次，因此总工作量为 N^2/2，即 O(N^2)。

******示例 4
这与上面的类似，但是现在我们有两个不同的数组。

void printUnorderedPairs(int[] arrayA,int[] arrayB){
	for(int i=0;i<arrayA.length;i++){
		for(int j=0;i<arrayB.length;j++){
			if(arrayA[i]<arrayB[j]){
				System.out.println(arrayA[i]+","+arrayB[j]);
			}
		}
	}
}

我们可以拆开来分析。j的for循环中的if语句o1

我们可以拆开来分析。j 的 for 循环中的 if 语句是 O(1) 时间，因为它只是一个常量时间语句的序列。

我们现在有了这个：

1 	void printUnorderedPairs(int[] arrayA, int[] arrayB) {
2 		for (int i= 0; i < arrayA.length; i++) {
3 			for (int j = 0; j < arrayB.length; j++) {
4 				/* O(1) work */
5 			}
6 		}
7 	}
对于 arrayA 的每个元素，内部的 for 循环都会进行 b 次迭代，其中 b = arrayB.length。如果 a = arrayA.length，则运行时间为 O(ab)。

如果你说 O(N^2)，那今后请你记住这个错误。它不是O(N^2)，因为有两个不同的输入。两者都重要。这是一个非常常见的错误。


示例 5
那么这段奇怪的代码呢？

void printUnorderedPairs(int[] arrayA,int[] arrayB){
	for(int i=0;i<arrayA.length;i++){
		for(int j=0;i<arrayB.length;j++){
			for(int k=0;k<100000;k++){
				System.out.println(arrayA[i]+","+arrayB[j]);
			}
		}
	}
}

这里并没有什么实质性的改变。100,000 个单位话费的时间仍然是常数，所以运行时间还是 O(ab)。

示例 6
下面的代码反转一个数组。它的运行时间是多少？

void reverse(int[] array){
	for(int i=0;i<array.length/2;i++){
		int other=array.length-i-1;
		int temp=array[i];
		array[i]=array[other];
		array[other]=temp;
	}
}
该算法运行时间为o-n。它仅遍历数组的一半（就迭代而言）不会影响big o time）。这个算法至少和这些


示例 7
以下哪项哪一个等价于 O(N)？为什么？

O(N + P), where P < N/2

O(2N)

O(N + log N)

O(N + M)

让我们来看看这些。

如果 P < N/2，那么我们知道 N 是主导项所以我们可以去掉 O(P)。

O(2N) 等于 O(N)，因为我们丢弃了常数。

O(N) 主导 O(log N)，所以我们可以去掉 O(log N)。

N 和 M 之间没有确定的关系，所以我们必须保留两个变量。

因此，除了最后一个，其余的都等价于O(N)。

示例 8
假设我们有一个算法，它接收一个字符串数组，对每个字符串进行排序，然后对整个数组进行排序。运行时间是多少？

很多候选人会得出这样的结论：对每个字符串排序是 O(N log N)，并且我们必须对每个字符串进行排序，因此就是 O(N*N log N)。我们还必须对这个数组进行排序，所以这是一个额外的 O(N log N) 的工作。因此，总的运行时间是 O(N²log N + N log N)，也就是 O(N²log N)。

这是完全错误的。你发现错误了吗？

问题在于我们以两种不同的方式使用 N。在一种情况下，它是字符串的长度（哪个字符串？）。在另一种情况下，它是数组的长度。

在面试中，你可以完全不使用变量“ N”，或者仅在对 N 可以表示什么没有歧义时才使用它，以防止出现此错误。

实际上，我甚至不会在这里使用 a 和 b，或者 m 和 n。因为很容易忘记哪个是哪个，然后把它们完全搞混了。O(a^2) 运行时与 O(a*b) 运行时完全不同。

让我们定义新的术语，并使用符合逻辑的名称。

设 s 为最长字符串的长度。

设 a 为数组的长度。

现在我们可以通过以下几个部分来解决这个问题：

排序每个字符串为 O(s log s)。

我们必须对每个字符串（这里是字符串 a）执行此操作，所以是 O(a*s log s)。

现在我们要对所有的字符串排序。有字符串 a，所以你可能会说这要花费 O(a log a) 时间。这是大多数候选人会说的话。你还应该考虑到需要比较字符串。每个字符串比较需要 O(s) 的时间。存在 O(a log a) 个比较，因此这将花费 O(a*s log a) 的时间。

如果把这两部分相加，就得到 O(a*s(log a + log s))。

就是这个。没有办法进一步减少它。

#示例 9
下面的简单代码将平衡二叉搜索树中所有节点的值相加。它的运行时间是多少？

int sum(Node node){
	if(node==null){
		return 0;
	}
	return sum(node.left)+node.value+sum(node.right);
}



6.10.9.1 它的意义
最简单明了的方式是思考它的意义。代码访问树中的每个节点仅一次，并且每次“访问”
（不包括递归调用）都做了常量时间的工作。
因此，运行时间与节点数呈线性关系。如果有 N 个节点，那么运行时间就是 Ο(N)。
6.10.9.2 递归模式
在 6.9 节，讨论了递归函数有多个分支时如何计算运行时间。让我们在这里试试这种方法。
我们说过，带有多个分支的递归函数的运行时间通常是 Ο(branchesdepth)。每个调用有两个
分支，因此，称之为 Ο(2深度)。
在这一点上，很多人可能会认为事情不太对。因为这是一个指数级的算法。要么是逻辑上
有些缺陷，要么是无意中创造了一个指数级的算法。
第二种说法是正确的。确实有一个指数级的算法。但它并不像人们想的那样糟糕。考虑一
下它的指数对应何种变量。
深度是多少呢？这是一个平衡二叉搜索树。因此，如果总节点是 N，那么深度大概是 log N。
由上面的公式，得到 Ο(2log N)。
回想下 log2的含义：
2P
 = Q -> log2Q = P 2log N是多少呢？涉及 2 和 log 之间的关系，应该可以简化一下。
让 P = 2log N
。由 log2的定义，可以把它写成 log2P = log2N，也就是说 P = N。 让 P = 2log N
-> log2P = log2N
-> P = N
-> 2log N = N
因此，代码的运行时间是 Ο(N)，N 是节点的个数。



示例 10
以下方法来检查一个数字是否为质数，具体是通过检查小于它的数字的可除性。它只需要向上到 n 的平方根，因为如果 n 能被一个比它平方根大的数整除，那么它就能被比它小的数整除。

例如，虽然 33 可以被 11 整除（11大于33的平方根），与 11 的“对应”的因数为 3（3 * 11 = 33）。因此在使用 3 时已经将 33 排除为质数了。

该函数的时间复杂度是多少？

boolean isPrime(int n){
	for(int x=2;x*x<n;x++){
		if(n%x==0){
			retrun false;
		}
	}
	return true;
}

很多人把这个问题想错了。但如果你仔细考虑你的逻辑，这是相当容易的。

for 循环内部的工作是常数。因此，我们只需要知道在最坏的情况下 for 循环要执行多少次迭代。

for循环将在 x = 2 时开始，在 x*x = n 时结束。换句话说，当 x =√n 时（x等于n的平方根），for 循环停止。

这个 for 循环实际上是这样的：

1 	boolean isPrime(int n) {
2 		for (int x = 2; x =< sqrt(n); x++) { 
3 			if (n % x == 0) {
4 				return false;
5 			}
6 		}
7 		return true;
8 	}

这需要 O(√n) 的时间。




示例 11
下面的代码计算 n!（n的阶乘）。它的时间复杂度是多少？
int factorial(int n){
	if(n<0){
		return -1;
	}else if(n==0){
		return 1;
	}else{
		return n*factorial(n-1);
	}
}

这是一个从n到n-1到n-2到1的递归，花费o-n时间。

例子12:
计算字符串的所有排序
void permutation(String str){
	permutation(str,"");
}
void permutation(String str,String prefix){
	if(str.length()==0){
		System.out.println(prefix);
	}else{
		for(int i=0;i<str.length();i++){
			string rem=str.substring(0,i)+str.substring(i+1);
			permutation(rem,prefix+str.charAt(i));
		}

	}
}

我们可以通过调用permutation的方法的次数和每次调用的时间来考虑这个问题。我们的目标是尽可能缩小上限。

permutation方法在基本情况下被调用多少次？

如果生成一个排列，则需要为每个slot选择字符。假设字符串中有7个字符。在第一个slot中，7个选择。选好字母后，下一个slot6个选择，以此类推。

因此，选项的总数为7*6*5*4*3*2*1，也就是7！

这告诉我们有n个排列。因此permutation被调用了n！次。

permutation方法在基本情况之前被调用多少次。

但是，当然我们还需要考虑9-12行被命中的次数。绘制一个表示所有调用的大型调用树。有n！个叶子，如上所示。每个叶子连接到长度为n的路径上。因此我们知道不会超过n*n!个该树中的节点*函数调用。

每个调用需要多少时间？

执行第 7 行需要 O(n) 时间，因为每个字符都需要打印。

由于字符串连接，第 10 行和第 11 行也将花费 O(n) 时间。注意 rem、prefix 和 str. charAt(i) 的长度之和始终为 n。

因此，调用树中的每个节点都对应 O(n) 的工作。

总运行时间是多少？

因为我们调用了 O(n * n!) 次（作为上限）permutation 方法，每次调用都需要 O(n)次，所以总的运行时不会超过 O(n^2 * n!)。

通过更复杂的数学，我们可以推导出一个更紧凑的运行时方程（尽管不一定是一个漂亮的封闭表达式）。几乎可以肯定，这超出了任何普通面试的范围。


示例 13
下面的代码计算第 N 个斐波那契数。

int fib(int n){
	if(n<=0) return 0;
	else if(n==1) return 1;
	return fib(n-1)+fib(n-2);
}

我们可以使用之前为递归调用建立的模式：O(branches^depth)。

每个调用有 2 个分支，我们深度到 N，因此运行时是 O(2^N)。

通过一些非常复杂的数学运算，我们实际上可以获得更紧凑的运行时。时间确实是指数的，但实际上更接近 O(1.6^N)。它不是 O(2^N) 的原因是，在调用堆栈的底部，有时只有一个调用。事实证明，许多节点都位于底部（大多数树都是这样），因此，单次调用与两次调用实际上会产生很大的差异。但是，说 O(2^N) 在面试范围内就足够了（并且，如果你阅读了有关第 39 页的 big theta 的说明，就会知道这从技术上讲也是正确的）。你可能会得到“额外的分数”，如果你能意识到它实际上会比这少。


一般来说，当你看到一个具有多个递归调用的算法时，你需要考虑指数运行时。

示例 14
下面的代码打印从 0 到 n 的所有斐波那契数。它的时间复杂度是多少？

void allFib(int n){
	for(i=0;i<n;i++){
		System.out.println(i+":"+fib(i));
	}
}

int fib(n){
	if(n<=0) return 0;
	else if(n==1) return 1;
	return fib(n-1)+fib(n-2);
}

许多人会急于得出这样的结论，因为 fib(n) 需要 O(2^n) 的时间，被调用 n 次，那么它就是 O(n2^n)。

不要这么快下结论。你能找出逻辑上的错误吗？

错误是 n 是在变化的。的确，fib(n) 需要 O(2^n) 的时间，但重要的是 n 的值是多少。

相反，让我们遍历每个调用。

fib(1) -> 2^1 steps 
fib(2) -> 2^2 steps 
fib(3) -> 2^3 steps 
fib(4) -> 2^4 steps
...
fib(n) -> 2^n steps

因此，总工作量为：

2^1 + 2^2 + 2^3 + 2^4 + ... + 2^n
正如我们在第 44 页上展示的那样，这是 2^(n+1)。因此，计算前 n 个斐波那契数的运行时间（使用这个糟糕的算法）仍然是 O(2^n)。



示例 15
下面的代码打印从 0 到 n 的所有斐波那契数。但是，这一次，它将先前计算出的值存储（即缓存）在整数数组中。如果已经计算过，它将仅返回缓存。它的运行时间是多少？

void allFib(int n){
	int[] memo=new int[n+1];
	for(int i=0;i<n;i++){
		System.out.print(i+":"+fib(i,memo))
	}
}

int fib(int n,int[] memo){
	if(n<=0) return 0;
	else if(n==1) return 1;
	else if(memo[n]>0) return memo[n];

	memo[n]=fib(n-1,memo)+fib(n-2,memo);
	return memo[n];
}

fib(1) -> return 1
fib(2)
	fib(1) -> return 1 
	fib(0) -> return 0 
	store 1 at memo[2]
fib(3)
	fib(2) -> lookup memo[2] -> return 1 
	fib(1) -> return 1
	store 2 at memo[3]
fib(4)
	fib(3) -> lookup memo[3] -> return 2 
	fib(2) -> lookup memo[2] -> return 1 
	store 3 at memo[4]
fib(5)
	fib(4) -> lookup memo[4] -> return 3 
	fib(3) -> lookup memo[3] -> return 2 
	store 5 at memo[5]
...

在每次对 fib(i)的调用中，已经计算并存储过 fib(i-1)和 fib(i-2)的值。只需要查找这
些值，计算它们的和，存储新的结果，然后返回。这个过程需要常数时间。
做了 N 次常数时间的工作，因而运行时间是 Ο(n)。
这种称为制表的技术，常用于指数级的递归算法的优化。

示例 16
下面的函数从1到n（包括 1 和 n）打印2的幂。例如，如果 n 是4，它会输出 1、2 和 4。它的运行时间是多少？
int powersOf2(int n){
	if(n<1){
		return 0;
	}else if(n==1){
		System.out.println(1);
		return 1;
	}else{
		int prev=powerOf2(n/2);
		int curr=prev*2;
		System.out.println(curr);
		return curr;
	}
}
有好几种方法可以计算运行时间

6.10.16.1 做了什么
让我们过一遍powersOf2(50)


powersOf2(50) 
 -> powersOf2(25) 
 -> powersOf2(12) 
 -> powersOf2(6)
-> powersOf2(3) 
 -> powersOf2(1) 
 -> print & return 1 
 print & return 2 
 print & return 4 
 print & return 8 
 print & return 16 
 print & return 32

 很显然运行时间就是50处以2的次数，一直除到开始处理基线条件（1）。正如6.8节所说，从n到1的次数应该是o（logn）。

 6.10.16.2
 我们也可以通过思考代码应做什么来探讨运行时间。它应该是计算从 1 到 n 中 2 的幂数。
每次调用 powersOf2 的结果是输出一个确定的数字并返回（排除递归调用的情况）。所以
算法最后输出 13 个值，那么 powersOf2 就被调用了 13 次。
在本例中，知道它打印 1 到 n 中所有 2 的幂数。因此，函数被调用的次数（相当于它的运
行时间）应当等于 1 到 n 中 2 的幂数的个数。
1 到 n 中有 log N 个 2 的幂数，因此，运行时间是 Ο(log n)。


处理运行时间最终的方式是思考 n 变大时运行时间的变化。这也正是大 Ο 的意义所在。
如果 N从 P增加到 P + 1，调用 powersOf2 的次数可能根本不会变。什么时候调用 powersOf2
的次数会增加？n 每增加一倍，它就会增加一次。
所以，每次 n 加倍，调用 powersOf2 的次数就增加 1。因此，调动 powersOf2 的次数等于
你把 1 加倍到 n 的次数，也就是 x，x 满足 2x
 = n。 x 是多少？它的值是 log n。 这正是 x = log n 的意义所在。



(1) 下面的代码计算 a 和 b 的乘积。运行时间是多少？
int product(int a, int b) { 
 int sum = 0; 
 for (int i = 0; i < b; i++) { 
 sum += a; 
 } 
 return sum; 
} 

o-b，for循环仅仅是遍历b。

(2) 下面的代码计算 ab
。运行时间是多少？
int power(int a, int b) { 
 if (b < 0) { 
 return 0; // 错误
 } else if (b == 0) { 
 return 1; 
 } else { 
 return a * power(a, b - 1); 
 } 
}

o-b，递归代码循环b次，因为每一次减去一个。

(3) 下面的代码计算 a % b。运行时间是多少？
int mod(int a, int b) { 
 if (b <= 0) { 
 	return -1; 
 } 
 int div = a / b; 
 return a - div * b; 
} 
o-1，它做的工作是常数时间。

(4) 下面的代码计算整数除法。运行时间是多少（假设 a 和 b 都是正数）？
int div(int a, int b) { 
 int count = 0; 
 int sum = b; 
 while (sum <= a) { 
 sum += b; 
 count++; 
 } 
 return count; 
} 
o(a/b)。变量count最终会等于a/b。while循环遍历了count次。因此，它遍历了a/b次。

(5) 下面的代码计算一个数字的整数平方根。如果不是一个完美平方根（没有整数平方根），
就会返回1。它是通过反复猜测得到整数平方根的。比如，如果 n 是 100，它第一次猜
50。高了？就尝试低一点的——1 到 50 的一半。它的运行时间是多少？
int sqrt(int n) { 
 return sqrt_helper(n, 1, n); 
} 
int sqrt_helper(int n, int min, int max) { 
 if (max < min) return -1; // 没有平方根
 int guess = (min + max) / 2; 
 if (guess * guess == n) { // 找到它了! 
 return guess; 
 } else if (guess * guess < n) { //太低了
 return sqrt_helper(n, guess + 1, max); // 试试大的数
 } else { // 太高了
 return sqrt_helper(n, min, guess - 1); // 试试小的数
 } 
} 
o-logn。本质通过二分查找去寻找平方根。因此运行时间是log-n。

(6) 下面的代码计算一个数字的整数平方根。如果不是一个完美的平方根（没有整数平方根），
就会返回1。它尝试越来越大的数字直到找到正确的值（除非太高）。它的运行时间
是多少？
int sqrt(int n) { 
 for (int guess = 1; guess * guess <= n; guess++) { 
 if (guess * guess == n) { 
 return guess; 
 } 
 } 
 return -1; 
} 
o-sqrt(n) 这就是个简单循环，当guess*guess>n(或者换个说法，当guess>sqrt(n))停止。

(7) 如果一棵二叉搜索树不平衡，它寻找一个节点（在最坏情况下）需要多长时间？
O(n)，n 是树的节点数。寻找一个元素的最大时间取决于树的深度。这个树可能是笔直向下
的一列，深度为 n。


(8) 如果你在一棵二叉树中查找某个值，但它不是一棵二叉搜索树。它的时间复杂度是多少？
O(n)。节点上没有任何排序的属性，只好搜索完全部节点。


(9) appendToNew 方法通过创建一个更长的新数组并返回它来向数组添加一个值。你使用
appendToNew 方法创建了一个 copyArray 函数，它反复地调用 appendToNew。此时复制
数组需要多长时间？
int[] copyArray(int[] array) { 
 int[] copy = new int[0]; 
 for (int value : array) { 
 copy = appendToNew(copy, value); 
 } 
 return copy; 
} 
int[] appendToNew(int[] array, int value) { 
 // 复制所有元素到一个新数组
 int[] bigger = new int[array.length + 1]; 
 for (int i = 0; i < array.length; i++) { 
	 bigger[i] = array[i]; 
 } 
 // 添加新元素
 bigger[bigger.length - 1] = value; 
 return bigger; 
} 
O(n2)，n 是数组中元素的个数。第一次调用 appendToNew 复制 1 次。第二次调用复制 2 次。
第三次调用复制 3 次。以此类推。总时间是 1 到 n 的和，即 Ο(n2)。

(10) 下面的代码把一个数字中每位数字相加。它的大 O 时间是多少？
int sumDigits(int n) { 
 int sum = 0; 
 while (n > 0) { 
 sum += n % 10; 
 n /= 10; 
 } 
 return sum; 
} 
O(log n)。运行时间是数字的位数。一个有 d 位的数字，值最大为 10d。如果 n = 10d
，那么 d = log n。因此，运行时间是 O(log n)。


(11) 下面的代码打印所有长度为 k 的字符串，要求字符有序。它先生成所有长度为 k 的字符
串，然后检查它是否有序。它的运行时间是多少？
int numChars = 26; 
void printSortedStrings(int remaining) { 
 	printSortedStrings(remaining, ""); 
} 
void printSortedStrings(int remaining, String prefix) { 
 if (remaining == 0) { 
 	if (isInOrder(prefix)) { 
		 System.out.println(prefix); 
 } 
 } else { 
 for (int i = 0; i < numChars; i++) { 
 char c = ithLetter(i); 
 printSortedStrings(remaining - 1, prefix + c); 
 } 
 } 
} 
boolean isInOrder(String s) { 
 for (int i = 1; i < s.length(); i++) { 
 int prev = ithLetter(s.charAt(i - 1)); 
 int curr = ithLetter(s.charAt(i));
 if (prev > curr) { 
 return false; 
 } 
 } 
 return true; 
} 
char ithLetter(int i) { 
 return (char) (((int) 'a') + i); 
} 
O(kck)，k 是字符串的长度，c 是字母表中字母的个数。生成每个字符串需要 Ο(ck)的时间。
然后，需要检查它们每一个是否都排序了，这需要 O(k)的时间。


(12) 以下代码计算两个数组的交集（相同元素的个数）。假设两个数组没有重复。它先排序一
个数组（数组 b），接着通过迭代检查（通过二分查找）另一个数组的值是否在 b 中来计
算交集。它的运行时间是多少？
int intersection(int[] a, int[] b) { 
 mergesort(b); 
 int intersect = 0; 
 for (int x : a) { 
 if (binarySearch(b, x) >= 0) { 
 intersect++; 
 } 
 } 
 return intersect; 
}
首先排序数组b需要o-blogb时间。接着对a的每个元素用o-logb的时间做二分查找。第二部分会花o-alogb的时间


CH7

技术面试题是许多顶尖科技公司面试的主要内容，其中一些难题会令许多面试者望而却步，
但其实这些题是有合理的解决方法的。
7.1 准备事项
多数求职者只是通读一遍问题和解法，囫囵吞枣。这好比试图单凭看问题和解法就想学会
微积分。你得动手练习如何解题，单靠死记硬背效果不彰。
就本书的面试题以及你可能遇到的其他题目，请参照以下几个步骤。
(1) 尽量独立解题。本书后面有一些提示可供参考，但请尽量不要依赖提示解决问题。许多
题目确实难乎其难，但是没关系，不要怕！此外，解题时还要考虑空间和时间效率。
(2) 在纸上写代码。在电脑上编程可以享受到语法高亮、代码完整、调试快速等种种好处，
在纸上写代码则不然。通过在纸上多多实践来适应这种情况，并对在纸上编写、编辑代码之缓
慢习以为常。
(3) 在纸上测试代码。就是要在纸上写下一般用例、基本用例和错误用例等。面试中就得这
么做，因此最好提前做好准备。
(4) 将代码照原样输入计算机。你也许会犯一大堆错误。请整理一份清单，罗列自己犯过的
所有错误，这样在真正面试时才能牢记在心。
此外，尽量多做模拟面试。你和朋友可以轮流给对方做模拟面试。虽然你的朋友不见得受
过什么专业训练，但至少能带你过一遍代码或者算法面试题。你也会在当面试官的体验中，受
益良多。

7.2 必备的基础知识
许多公司关注数据结构和算法面试题，并不是要测试面试者的基础知识。然而，这些公司
却默认面试者已具备相关的基础知识。
7.2.1 核心数据结构、算法及概念
大多数面试官都不会问你二叉树平衡的具体算法或其他复杂算法。老实说，离开学校这么
多年，恐怕他们自己也记不清这些算法了。
一般来说，你只要掌握基本知识即可。下面这份清单列出了必须掌握的知识

数据结构 算 法 概 念
链表 广度优先搜索 位操作
树、单词查找树、图 深度优先搜索 内存（堆和栈）
栈和队列 二分查找 递归
堆 归并排序 动态规划
向量/数组列表 快排 大 O 时间及空间，哈希表

对于上述各项题目，务必掌握它们的具体用法、实现方法、应用场景以及空间和时间复
杂度。
一种不错的方法就是练习如何实现数据结构和算法（先在纸上，然后在电脑上）。你会在这
个过程中学到数据结构内部是如何工作的，这对很多面试而言都是不可或缺的。
你错过上面那段了吗？千万不要错过，这非常重要。如果对上面列出的某个数据
结构和算法感觉不能运用自如，就从头开始练习吧。
其中，hash table是必不可少的一个题目。对这个数据结构，务必要胸有成竹。


7.2.2 2 的幂表
下面这张表会在很多涉及可扩展性或者内存排序限制等问题上助你一臂之力。尽管不强求
你记下来，可是记住总会有用。你至少应该轻车熟路。
2 的幂 准确值（X） 近 似 值 X 字节转换成 MB、GB 等
7 128 
8 256 
10 1024 一千 1 K 
16 65 536 64 K 
20 1 048 576 一百万 1 MB 
30 1 073 741 824 十亿 1 GB 
32 4 294 967 296 4 GB 
40 1 099 511 627 776 一万亿 1 TB


7.3 解题步骤
下面的流程图将教你如何逐步解决一个问题。要学以致用。你可以从 CrackingTheCodingInterview.com 下载这个提纲及更多内容。


面试期待
面试本就困难。如果你无法立刻得出答案，那也没有关系，这很正常，并不代表什么。
注意听面试官的提示。面试官有时热情洋溢，有时却意兴阑珊。面试官参与程度取决于你
的表现、问题的难度以及该面试官的期待和个性。
当你被问到一个问题或者当你在练习时，按下面的步骤完成解题。
7.3.1.1 认真听
也许你以前听过这个常规性建议：确保听清楚题。但我给你的建议不止这一点。
邮电
56 第 7 章 技术面试题
当然了，你首先要保证听清题，其次弄清楚模棱两可的地方。
但是我要说的不止如此。
举个例子，假设一个问题以下列其中一个话题作为开头，那么可以合理地认为它给出的所
有信息都并非平白无故的。
“有两个排序的数组，找到……”
你很可能需要注意到数据是有序的。数据是否有序会导致最优算法大相径庭。
“设计一个在服务器上经常运行的算法……”
在服务器上/重复运行不同于只运行一次的算法。也许这意味你可以缓存数据，或者意味着
你可以顺理成章地对数据集进行预处理。
如果信息对算法没影响，那么面试官不大可能（尽管也不无可能）把它给你。
很多求职者都能准确听清问题。但是开发算法的时间只有短短的十来分钟，以至于解决问
题的一些关键细节被忽略了。这样一来无论怎样都无法优化问题了。
你的第一版算法确实不需要这些信息。但是如果你陷入瓶颈或者想寻找更优方案，就回头
看看有没有错过什么。
即使把相关信息写在白板上也会对你大有裨益。

7.3.1.2 画个例图
画个例图能显著提高你的解题能力，尽管如此，还有如此多的求职者只是试图在脑海中解
决问题。
当你听到一道题时，离开椅子去白板上画个例图。
不过画例图是有技巧的。首先你需要一个好例子。
通常情况下，以一棵二叉搜索树为例，求职者可能会画如下例图。
这是个很糟糕的例子。第一，太小，不容易寻找模式。第二，不够具体，二叉搜索树有值。
如果那些数字可以帮助你处理这个问题怎么办？第三，这实际上是个特殊情况。它不仅是个平
衡树，也是个漂亮、完美的树，其每个非叶节点都有两个子节点。特殊情况极具欺骗性，对解题
无益。
实际上，你需要设计一个这样的例子。
 具体。应使用真实的数字或字符串（如果适用的话）。
 足够大。一般的例子都太小了，要加大 0.5 倍。
 具有普适性。请务必谨慎，很容易不经意间就画成特殊的情况。如果你的例子有任何特
殊情况（尽管你觉得它可能不是什么大事），也应该解决这一问题。
尽力做出最好的例子。如果后面发现你的例子不那么正确，你应该修复它。


7.3.1.3 给出一个蛮力法
一旦完成了例子（其实，你也可以在某些问题中调换 7.3.1.2 步和 7.3.1.3 步的顺序），就给
出一个蛮力法。你的初始算法不怎么好也没有关系，这很正常。
一些求职者不想给出蛮力法，是因为他们认为此方法不仅显而易见而且糟糕透顶。但是事
实是：即使对你来说轻而易举，也未必对所有求职者来说都这样。你不会想让面试官认为，即
7.3 解题步骤 57 

使解出这一简单算法对你来说也得绞尽脑汁。
初始解法很糟糕，这很正常，不必介怀。先说明该解法的空间和时间复杂度，再开始优化。

7.3.1.4 优化
你一旦有了蛮力法，就应该努力优化该方法。以下技巧就有了用武之地。
(1) 寻找未使用的信息。你的面试官告诉过你数组是有序的吗？你如何利用这些信息？
(2) 换个新例子。很多时候，换个不同的例子会让你思路畅通，看到问题模式所在。
(3) 尝试错误解法。低效的例子能帮你看清优化的方法，一个错误的解法可能会帮助你找到
正确的方法。比方说，如果让你从一个所有值可能都相等的集合中生成一个随机值。一个错误
的方法可能是直接返回半随机值。可以返回任何值，但是可能某些值概率更大，进而思考为什
么解决方案不是完美随机值。你能调整概率吗？
(4) 权衡时间、空间。有时存储额外的问题相关数据可能对优化运行时间有益。
(5) 预处理信息。有办法重新组织数据（排序等）或者预先计算一些有助于节省时间的值吗？
(6) 使用散列表。散列表在面试题中用途广泛，你应该第一个想到它。
(7) 考虑可想象的极限运行时间（详见 7.9 节）。
在蛮力法基础上试试这些技巧，寻找 BUD 的优化点。

7.3.1.5 梳理
明确了最佳算法后，不要急于写代码。花点时间巩固对该算法的理解。
白板编程很慢，慢得超乎想象。测试、修复亦如此。因此，要尽可能地在一开始就确保思
路近乎完美。
梳理你的算法，以了解它需要什么样的结构，有什么变量，何时发生改变。
伪代码是什么？如果你更愿意写伪代码，没有问题。但是写的时候要当心。基本
的步骤（(1) 访问数组。(2) 找最大值。(3) 堆插入。）或者简明的逻辑（if p < q, move p. 
else move q.）值得一试。但是如果你用简单的词语代表 for 循环，基本上这段代码就
烂透了，除了代码写得快之外一无是处。
你如果没有彻底理解要写什么，就会在编程时举步维艰，这会导致你用更长的时间才能完
成，并且更容易犯大错。

7.3.1.6 实现
这下你已经有了一个最优算法并且对所有细节都了如指掌，接下来就是实现算法了。
写代码时要从白板的左上角（要省着点空间）开始。代码尽量沿水平方向写（不要写成一
条斜线），否则会乱作一团，并且像 Python 那样对空格敏感的语言来说，读起来会云里雾里，
令人困惑。
切记：你只能写一小段代码来证明自己是个优秀的开发人员。因此，每行代码都至关重要，
一定要写得漂亮。
写出漂亮代码意味着你要做到以下几点。
 模块化的代码。这展现了良好的代码风格，也会使你解题更为顺畅。如果你的算法需
要使用一个初始化的矩阵，例如{{1, 2, 3}, {4, 5, 6}, ...}，不要浪费时间去写初
始化的代码。可以假装自己有个函数 initIncrementalMatrix(int size)，稍后需要
时再回头写完它。

 错误检查。有些面试官很看重这个，但有些对此并不“感冒”。一个好办法是在这里加
上 todo，这样只需解释清楚你想测试什么就可以了。
 使用恰到好处的类、结构体。如果需要在函数中返回一个始末点的列表，可以通过二维
数组来实现。当然，更好的办法是把 StartEndPair（或者 Range）对象当作 list 返回。
你不需要去把这个类写完，大可假设有这样一个类，后面如果有富裕时间再补充细节即可。
 好的变量名。到处使用单字母变量的代码不易读取。这并不是说在恰当场合（比如一个
遍历数组的普通 for 循环）使用 i 和 j 就不对。但是，使用 i 和 j 时要多加小心。如果
写了类似于 int i = startOfChild(array)的变量名称，可能还可以使用更好的名称，
比如 startChild。
然而，长的变量名写起来也会比较慢。你可以除第一次以外都用缩写，多数面试官都能同
意。比方说你第一次可以使用 startChild，然后告诉面试官后面你会将其缩写为 sc。
评价代码好坏的标准因面试官、求职者、题目的不同而有所变化。所以只要专心写出一手
漂亮的代码即可，尽人事、知天命。
如果发现某些地方需要稍后重构，就和面试官商量一下，看是否值得花时间重构。通常都
会得到肯定答复，偶尔不是。
如果觉得一头雾水（这很常见），就再回头过一遍。






