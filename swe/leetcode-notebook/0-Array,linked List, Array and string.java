阵列 - DVD 盒？
报告问题
假设你家里有一堆 DVD 想要整齐地排列。存储这样的东西的理想选择是什么？你可以找到一个足够大的纸板箱（或其他一些盒子）来整齐地排列所有的 DVD，对吧？就这么简单。但是，您可能想要将新 DVD 添加到盒子中，或者您可能想要摆脱过去已经观看了一百万次的旧 DVD。这个盒子的一个重要考虑是你只能把 DVD 放在里面，别无其他；例如，你不会把衣服放在里面。该盒子将包含多个项目，但所有项目的类型都相同。在这种情况下，该类型是 DVD。相同类型的项目共享属性。对于 DVD，这些属性包括：

所有的 DVD 都放在塑料盖内。
封面将包含电影名称、演员阵容和各种其他细节。
所有封面的大小都完全相同，并且只包含一张 DVD。
您实际上可能不会说出 DVD 盒的名称，但是当您想让您的妹妹取 DVD 时，您会告诉她 DVD 在您的“DVD 盒”内，她会立即知道在哪里可以找到该盒。这是一个非常简单但现实的场景，易于理解和关联。所以，现在让我们转向计算机世界并将这个例子移植到编程中。


假设您被告知需要构建一些软件来跟踪库存中的所有 DVD。这与我们刚刚在上面描述的场景完全相同，但规模要大得多。因此，让我们将 DVD 盒想象成一个虚拟 DVD 库。对于每张 DVD，您将拥有某些属性，这些属性将是电影本身的特定属性。

除了 DVD 的属性之外，您还会被告知库存中可以存储的 DVD 的最大数量。显然，您不会想要存储 1900 年代的古代电影，除非它们很受欢迎，对吗？假设您被告知要求保持最多只有 100 张 DVD 的库存。这是一条重要的信息，因为没有它，您将无法轻松找到适合所有 DVD 的大小合适的盒子。我们如何才能找到一个特定尺寸的盒子，最多可容纳 100 张 DVD？好吧，对我们来说幸运的是，我们不需要在物理上找到一个纸板箱或任何东西——有一个用于此目的的编程结构。该编程结构称为Array.

S什么是数组？
报告问题
数组是项目的集合。这些项目可以是整数、字符串、DVD、游戏、书籍——任何真的。这些项目存储在相邻（连续）内存位置。因为它们存储在一起，所以检查整个项目集合很简单。

那么，我们如何将其与物理 DVD 联系起来呢？好吧，您是否将 DVD 放在屋子里的多个位置？希望不是！大多数人将他们所有的 DVD 并排放在一个巨大的盒子里，或者放在书架上。我们这样做是为了如果我们需要找到特定的 DVD，我们可以快速搜索所有这些 DVD，而无需在房间之间跑来跑去。



创建数组
在计算机上，数组最多可以容纳N项目。的值N由您（程序员）在创建数组时决定。这与我们为 DVD 找到足够大的纸板箱时相同。此外，您还需要指定将进入数组的项目类型。

在Java 中，我们使用以下代码创建一个数组，最多可容纳 15 张 DVD。请注意，为了清楚起见，我们还包含了 DVD 的简单定义。

// The actual code for creating an Array to hold DVD's.
DVD[] dvdCollection = new DVD[15];

// A simple definition for a DVD.
public class DVD {
    public String name;
    public int releaseYear;
    public String director;

    public DVD(String name, int releaseYear, String director) {
        this.name = name;
        this.releaseYear = releaseYear;
        this.director = director;
    }

    public String toString() {
        return this.name + ", directed by " + this.director + ", released in " + this.releaseYear;
    }
}


运行上述代码后，我们现在有一个名为 的数组dvdCollection，其中包含一些15位置。每个地方可以放一张DVD。开始时，阵列中没有DVD；我们必须真正把它们放进去。

阵列最多只能容纳15DVD。如果我们得到第 16 张 DVD，我们将需要制作一个新阵列。我们将在下一章中了解如何处理空间不足。

不过，在我们开始实际将一些 DVD 放入阵列之前，您可能想知道的一件事是我们为什么要制作只有 15位置的阵列。为什么不让它容纳1000000DVD 以便我们确信我们总是有足够的空间？

嗯，原因与 DVD 的物理盒相同。1000000当您目前只有15DVD 并且实际上从不期望拥有更多DVD 时，您真的想找到一个可以容纳DVD的盒子100吗？100当您只希望每年获得一些新的时，现在是否值得购买一个可以容纳DVD的盒子？同时，它会占用您家中更多的空间。

这与Array完全相同，您家中的空间类似于计算机上的内存。如果您创建一个带有1000000空格的 Array 1000000，即使您只将15DVD 放入其中，计算机也会保留内存来存放DVD 。这段记忆在此期间不能用于其他任何事情——就像你房子里的空间被那个巨大的纸板箱占据了一样！

访问数组中的元素
报告问题
两个最原始的 Array 操作是将元素写入其中，以及从中读取元素。所有其他 Array 操作都建立在这两个基本操作之上。



将项目写入数组
要将 DVD 放入阵列中，我们需要决定将它放入 15 个位置中的哪一个。每个位置都使用范围为0到的数字标识N - 1。第 1 名是0，第 2 名是1，第 3 名是2……一直到第 15 名，也就是14。我们将这些标识每个位置的数字称为索引。

让我们把复仇者联盟的 DVD 放在我们上面创建的阵列的第八位。

DVD incrediblesDVD = new DVD("The Incredibles", 2004, "Brad Bird");
DVD findingDoryDVD = new DVD("Finding Dory", 2016, "Andrew Stanton");
DVD lionKingDVD = new DVD("The Lion King", 2019, "Jon Favreau");

// Put "The Incredibles" into the 4th place: index 3.
dvdCollection[3] = incrediblesDVD;

// Put "Finding Dory" into the 10th place: index 9.
dvdCollection[9] = findingDoryDVD;

// Put "The Lion King" into the 3rd place: index 2.
dvdCollection[2] = lionKingDVD;

请注意，我们将The Incredibles放入 Array 的 index 处3。如果我们现在运行下一段代码会发生什么？

DVD starWarsDVD = new DVD("Star Wars", 1977, "George Lucas");
dvdCollection[3] = starWarsDVD;

因为我们只是将Star Wars放入 Array 中的 index 3，The Incredibles不再在 Array 中。已经被覆盖了！如果我们在 scope 中仍然有incrediblesDVD变量，那么 DVD 仍然存在于计算机的内存中。如果没有，它就完全消失了！

从数组中读取项目
我们可以检查特定数组索引处的内容。

// Print out what's in indexes 7, 10, and 3.
System.out.println(dvdCollection[7]);
System.out.println(dvdCollection[10]);
System.out.println(dvdCollection[3]);

// Will print:

// The Avengers, directed by Joss Whedon, released in 2012
// null
// Star Wars, directed by George Lucas, released in 1977

请注意，因为我们还没有在索引 10 处放置任何东西，所以它包含的值是null。在其他语言中，例如C， Array 槽可以包含完全随机的数据。null如果 Array 包含对象，Java 总是将空的 Array 槽初始化为默认值，如果它包含基本类型。例如，该数组int []将包含0每个元素的默认值，float[]将包含默认值0.0，bool[]并将包含默认值false。



使用循环将项目写入数组
我们通常使用循环将大量值放入数组中。为了说明这一点，让我们看另一个例子。这一次，我们将创建一个ints数组并将第一个10平方数放入其中。
int[] squareNumbers=new int[10];

for(int i=0;i<10;i++){
    int square=(i+1)*(i+1);
    squareNumbers[i]=square;
}

Reading Items from an Array with a Loop
We can also use a loop to print out everything that's in the Array.

// Go through each of the Array indexes, from 0 to 9.
for (int i = 0; i < 10; i++) {
    // Access and print what's at the i'th index.
    System.out.println(squareNumbers[i]);
}

// Will print:
// 1
// 4
// 9
// 16
// 25
// 36
// 49
// 64
// 81
// 100

One last thing worth knowing now is that there's a more elegant way of printing out the values of an Array—a variant of the for loop, commonly referred to as a "for each" loop.

for(int square : squareNumbers){
    System.out.println(square);
}

You'll probably agree that this code is a lot simpler to read. We can use it whenever we don't need the index values. For actually writing the squares into the Array, it wouldn't have worked because we needed to work with the actual index numbers. You don't have to use a "for each" loop when you're starting out, but we recommend you become comfortable with it before interviews. Simple, elegant code is good code!

阵列容量 VS 长度
报告问题
如果有人问你 DVD Array 有多长，你的答案是什么？

您可能给出了两种不同的答案。

盒子可以容纳的 DVD 数量（如果已满），或
当前盒中 DVD 的数量。
两个答案都是正确的，并且两者的含义非常不同！了解它们之间的区别并正确使用它们很重要。我们称第一个为数组的容量，第二个为数组的长度。



阵列容量
假设我们已经创建了一个这样的新数组。

DVD[] array=new DVD[6];

在 处插入元素是否有效array[6]？在array[10]呢？

不，这些都无效。当我们创建阵列时，我们指定它可以容纳6DVD。这是阵列的容量。

记住，索引开始在0，我们只能插入在项目array[0]，array[1]，array[2]，array[3]，array[4]，和array[5]。试图把一个元素其他地方，如array[-3]，array[6]或array[100]会导致你的代码崩溃有ArrayIndexOutOfBoundsException！

Array 的容量必须在创建 Array 时确定。以后不能更改容量。回到我们的 DVD-in-a-cardboard-box 类比，改变 Array 的容量类似于试图使纸板箱变大。试图把一个固定尺寸的纸板箱做大是不切实际的，这和电脑上的Array一样！

那么，如果我们得到第 7 张 DVD 并且我们希望所有 DVD 都在同一个阵列中，我们该怎么办？好吧，不幸的是，它和我们的纸板箱一样。我们需要去弄一个更大的，然后将所有现有的 DVD 连同新的一起移入其中。

Java 中数组的容量可以通过查看其length属性的值来检查。这是使用代码完成的arr.length，其中arr是数组的名称。不同的编程语言有不同的方法来检查数组的长度。

int capacity=array.length;
System.out.println("The array has a capacity of"+capacity);

Running this code will give the following output:

The Array has a capacity of 6
Yup, it's a bit confusing that you need to access the capacity of an Array by using .length. Unfortunately, this is just something you'll need to get used to.

数组长度
长度的另一个定义是当前在阵列中的 DVD 或其他项目的数量。这是您需要跟踪自己的事情，如果您覆盖现有的 DVD 或在阵列中留下间隙，您将不会出现任何错误。

您可能已经注意到我们length在前面的示例中使用了一个变量来跟踪下一个空索引。

//create a new array with a capacity of 6
int[] array=new int[6];

//current length is 0, because it has 0 elements.
int length=0;

for(int i=0;i<3;i++){
    array[i]=i*i;
    length++;
}

System.out.println("The Array has a capacity of " + array.length);
System.out.println("The Array has a length of " + length);


运行此代码将提供以下输出：

数组的容量为 6
数组的长度为 3


//Handling Array Parameters
//Most Array questions on LeetCode have an Array passed in as a parameter, with no "length" or "capacity" parameter. What do we mean by this? Well, let's look at an example. Here is the description for the first problem you'll be asked to solve.

//Given a binary array, find the maximum number of consecutive 1s in this array.

//这是您获得的代码模板。


//唯一的参数是nums; 数组。你不可能在不知道多长时间的情况下解决这个问题nums。好吧，幸运的是它很简单。当 Array 作为参数给出时，没有任何附加信息，您可以安全地假设length == capacity。也就是说， Array 的大小正好可以容纳它的所有数据。因此，我们可以使用.length.

//不过要小心，数组是 0 索引的。容量/长度是项目的数量，而不是最高索引。最高指数是.length - 1。因此，要遍历 Array 中的所有项目，我们可以执行以下操作。

class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        // Hint: Initialise and declare a variable here to 
        // keep track of how many 1's you've seen in a row.
        int max=0;
        int count=0;

        for(int i=0;i<nums.length;i++){
            if nums[i]==1{count++;}
            else{
                max=Math.max(max.count);
                count=0;
            }
        }
        max=Math.max(max,count);
        return max;
 }
}

//You need to think about two things as far as any window is concerned. One is the starting point for the window. How do you detect that a new window of 1s has started? The next part is detecting the ending point for this window. How do you detect the ending point for an existing window? If you figure these two things out, you will be able to detect the windows of consecutive ones. All that remains afterward is to find the longest such window and return the size.

基本数组操作
报告问题
既然我们已经很好地了解了数组实际上是什么，以及它如何存储在计算机的物理内存中，那么下一个重要的事情就是数组支持的所有操作。Array 是一种数据结构，这意味着它以特定格式存储数据并支持对其存储的数据进行某些操作。考虑介绍部分中的 DVD 库存管理软件。让我们来看看您可能希望使用此软件执行的一些操作：

插入在特定位置的新DVD到集合。
如果不再将 DVD 保留在库存中，请从现有收藏中删除DVD。
在集合中搜索特定 DVD。这是我们收藏中最常执行的操作之一，因为我们的库存管理软件每天要使用数百次来查找用户要求的特定 DVD。
在本节中，我们将研究几乎所有数据结构都支持的三种基本操作；插入、删除和搜索。

数组插入
报告问题
在上一章中，我们研究了如何将元素写入数组。不过，正如我们即将看到的，还有更多的东西可以插入元素！

将新元素插入 Array 可以采用多种形式：

在数组的末尾插入一个新元素。
在数组的开头插入一个新元素。
在 Array 内的任何给定索引处插入新元素。


在数组末尾插入
在任何时候，我们都知道数组最后一个元素的索引，因为我们已经在length变量中跟踪它。在最后插入一个元素我们需要做的就是将新元素分配给当前最后一个元素之后的一个索引。


这与我们已经看到的几乎相同。这是创建一个可以容纳6项目的新数组的代码，然后将项目添加到前3三个索引中。

//declear an integer array of 6 elements
int[] intArray=new int[6];
int length=0;

//add 3 elements to the array
for(int i=0;i<3;i++){
    intArray[legnth]=i;
    length++;
}


Let's define a function, printArray, to help us visualise what's happening.

for(int i=0;i<intArray.length;i++){
    System.out.println("index"+i+"contains"+intArray[i]);
}

If we run our printArray function, we'll get the following output.
Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 0.
Index 4 contains 0.
Index 5 contains 0.
Notice how indexes 3, 4, and 5 all contain 0? This is because Java fills unused int Array slots with 0s.

Let's now add a 4th element. We'll add the number 10.

// Insert a new element at the end of the Array. Again,
// it's important to ensure that there is enough space
// in the array for inserting a new element.
intArray[length] = 10;
length++;

Notice how we also incremented the length? This is very important, next time when we add another element, we'll accidentally overwrite the one we just added!

Running printArray again, we'll get the following:

Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 10.
Index 4 contains 0.
Index 5 contains 0.


Inserting at the Start of an Array
To insert an element at the start of an Array, we'll need to shift all other elements in the Array to the right by one index to create space for the new element. This is a very costly operation, since each of the existing elements has to be shifted one step to the right. The need to shift everything implies that this is not a constant time operation. In fact, the time taken for insertion at the beginning of an Array will be proportional to the length of the Array. In terms of time complexity analysis, this is a linear time complexity: O(N)O(N), where NN is the length of the Array.

Here's what this looks like in code.

// First, we will have to create space for a new element.
// We do that by shifting each element one index to the right.
// This will firstly move the element at index 3, then 2, then 1, then finally 0.
// We need to go backwards to avoid overwriting any elements.
for(int i=3;i>=0;i--){
    intArray[i+1]=intArray[i];
}

// Now that we have created space for the new element,
// we can insert it at the beginning.
intArray[0]=20;

And here's the result of running printArray.

Index 0 contains 20.
Index 1 contains 0.
Index 2 contains 1.
Index 3 contains 2.
Index 4 contains 10.
Index 5 contains 0.


Inserting Anywhere in the Array
Similarly, for inserting at any given index, we first need to shift all the elements from that index onwards one position to the right. Once the space is created for the new element, we proceed with the insertion. If you think about it, insertion at the beginning is basically a special case of inserting an element at a given index—in that case, the given index was 0.


Again, this is also a costly operation since we could potentially have to shift almost all the other elements to the right before actually inserting the new element. As your saw above, shifting lots of elements one place to the right adds to the time complexity of the insertion task.

Here's what it looks like in code.

// Say we want to insert the element at index 2.
// First, we will have to create space for the new element.
for(int i=4;i>=2;i--){
    //shift each elment one position to the right
    intArray[i+1]=intArray[i];
}

// Now that we have created space for the new element,
// we can insert it at the required index.
intArray[2]=30;

/*
And here's the result of running printArray.

Index 0 contains 20.
Index 1 contains 0.
Index 2 contains 30.
Index 3 contains 1.
Index 4 contains 2.
Index 5 contains 10.


Does that all sound good? The main thing to be careful of is remembering that array.length gives you the total capacity of the Array. If you want to know the last used slot, you'll need to keep track of this yourself using a length variable. Other than that, just be careful to read any elements you want to keep, before you overwrite them!

We now have a fun problem for you to test your understanding on. Enjoy!
*/

//

Array Deletions
Report Issue
Now that we know how insertion works, it's time to look at its complement—deletion!

Deletion in an Array works in a very similar manner to insertion, and has the same three different cases:

Deleting the last element of the Array.
Deleting the first element of the Array.
Deletion at any given index.

Deleting From the End of an Array
Deletion at the end of an Array is similar to people standing in a line, also known as a queue. The person who most recently joined the queue (at the end) can leave at any time without disturbing the rest of the queue. Deleting from the end of an Array is the least time consuming of the three cases. Recall that insertion at the end of an Array was also the least time-consuming case for insertion.

So, how does this work in code? Before we look at this, let's quickly remind ourselves what the length of an Array means. Here is some code that creates an Array with room for 10 elements, and then adds elements into the first 6 indexes of it.

//declare
int[] intArray=new int[10];
//the array currently containts 0 elements
int length=0;
//add elements at first 6 indexes of the array
for(int i=0;i<6;i++){
    intArray[length]=i;
    length++;
}

Notice the length variable. Essentially, this variable keeps track of the next index that is free for inserting a new element. This is always the same value as the overall length of the Array. Note that when we declare an Array of a certain size, we simply fix the maximum number of elements it could contain. Initially, the Array doesn't contain anything. Thus, when we add new elements, we also increment the length variable accordingly.

Anyway, here's the code for deleting the last element of an Array.

// Deletion from the end is as simple as reducing the length
// of the array by 1.
length--;

Remember how insertion we were using this printArray function?
for(int i=0;i<intArray.length;i++){
    System.out.println("index"+i+"contains")+intArray[i]);
}

un this, and you'll get the following before the deletion:

Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 3.
Index 4 contains 4.
Index 5 contains 5.
And the following after:

Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 3.
Index 4 contains 4.

是的，就是这样！即使我们称其为删除，也不是我们实际上为新元素释放了空间，对吗？这是因为我们实际上并不需要释放任何空间。简单地覆盖某个索引处的值会删除该索引处的元素。在我们的示例中，长度变量告诉我们可以插入新元素的下一个索引，将其减少 1 确保下一个新元素覆盖已删除的元素。这也表明 Array 现在少了一个元素，这正是我们以编程方式想要的。



从数组开头删除
接下来是 Array 的所有删除操作中开销最大的操作——删除第一个元素。如果我们想删除数组的第一个元素，那将在0th索引处创建一个空位。为了填充那个位置，我们将索引处的元素1向左移动一步。通过涟漪效应，所有元素一直到最后一个元素都会向左移动一个位置。这种元素的转变需要在）○ (否) 时间，在哪里 NN 是数组中的元素数。

// Starting at index 1, we shift each element one position
// to the left.
for(int i=1;i<length;i++){
    int_array[i-1]=int_array[i];
}
length--;

Starting from index 0, we'll move every element one position to its left, effectively "deleting" the element at index 0. We also need to reduce length by 1 so that the next new element is inserted in the correct position.

And here's the output we'll get, with our updated printArray function.

Index 0 contains 1.
Index 1 contains 2.
Index 2 contains 3.
Index 3 contains 4.

Deleting From Anywhere in the Array
For deletion at any given index, the empty space created by the deleted item will need to be filled. Each of the elements to the right of the index we're deleting at will get shifted to the left by one. Deleting the first element of an Array is a special case of deletion at a given index, where the index is 0. This shift of elements takes O(K)O(K) time where KK is the number of elements to the right of the given index. Since potentially K = NK=N, we say that the time complexity of this operation is also O(N)O(N).


Here is the code to delete the element at index 1. To do this, we'll need to move over the elements after it in the Array.

//delete the lement at index 1
for(int i=2;i<length;i++){
    //shift each element one position to the left
    int_array[i-1]=int_array[i];
}
length--;

Notice that this works exactly like deleting the first element, except that we don't touch the elements that are at lower indexes than the element we're deleting.

Here is the output from the printArray function.

Index 0 contains 1.
Index 1 contains 3.
Index 2 contains 4.

Did that all make sense? To help you cement what you've learned, here's a couple of programming problems for you to try. You should try to solve them without making a new Array. Do this by using the deletion techniques we've investigated above.

Once you're done, we'll look at searching Arrays!

Search in an Array
Report Issue
Finally, we're going to look at the most important operation of all. More often than not, it comes down to the speed of searching for an element in a data structure that helps programmers make design choices for their codebases.

There's more than one way of searching an Array, but for now, we're going to focus on the simplest way. Searching means to find an occurrence of a particular element in the Array and return its position. We might need to search an Array to find out whether or not an element is present in the Array. We might also want to search an Array that is arranged in a specific fashion to determine which index to insert a new element at.

If we know the index in the Array that may contain the element we're looking for, then the search becomes a constant time operation—we simply go to the given index and check whether or not the element is there.



Linear Search
If the index is not known, which is the case most of the time, then we can check every element in the Array. We continue checking elements until we find the element we're looking for, or we reach the end of the Array. This technique for finding an element by checking through all elements one by one is known as the linear search algorithm. In the worst case, a linear search ends up checking the entire Array. Therefore, the time complexity for a linear search is O(N)O(N).


Let's see the linear search algorithm in action, with all the edge cases handled properly. When we say edge cases, we basically mean scenarios that you wouldn't expect to encounter. For example, the element you're searching for might not even exist in the Array. Or, an even rarer, but possible, scenario is that the input Array doesn't contain any elements at all, or perhaps it is null. It's important to handle all of these edge cases within the code.

public static boolean linearSearch(int[] array,int length,int elment){
    // Check for edge cases. Is the array null or empty?
    // If it is, then we return false because the element we're
    // searching for couldn't possibly be in it.
    if(array==null||length==0){
        return false;
    }
    //carry our linear search
    for(int i=0;i<length;i++){
        if(array[i]==element){
            return true;
        }
    }
    renturn false;
}

That's the function we can call to determine whether or not a particular element is in an Array. Notice how we take care of the edge cases before proceeding with the actual search, and that we don't check the rest of the elements once we'd found the element we were looking for.

There are many variations to this algorithm, such as returning the first location, last location, or all the locations (an element could be in the Array more than once). Let's see what happens when we call the linearSearch function.

public class ArraySearch{
    public static void main(String args[]){
        //Declear a new array of 6 elements
        int[] array=new int[6];
        int length=0;
        for(int i=0;i<6;i++){
            array[length++]=i;
        }
        System.out.println("Does the array contain 4?"+ArraySearch.linearSearch(array,length,4));
        System.out.println("Does the array contain 30?"+ArraySearch.linearSearch(array,length,30));
    }
    public static boolean linearSearch(int[] array, int length, int element) {
        // Check for edge cases
        if (array == null || length == 0) {
            return false;
        }

        // Check each element starting from the first one
        for (int i = 0; i < length; i++) {
            // We found the element at index i, so return true.
            if (array[i] == element) {
                return true;
            }
        }

        // We didn't find the element in the array.
        return false;
    }
}

正如预期的那样，我们能够4在 Array 中找到元素，但不能30。



二分查找
本节是可选的。它简要介绍了一种更高级的搜索算法，您将在稍后的探索卡中了解更多信息。

还有另一种搜索数组的方法。如果 Array 中的元素是有序的，那么我们可以使用二分查找。二分搜索是我们反复查看数组中的中间元素，并确定我们要查找的元素必须在左侧还是右侧。每次我们这样做时，我们都能够将仍然需要搜索的元素数量减半，使二分搜索比线性搜索快得多！

不过，二分搜索的缺点是它只有在数据被排序时才有效。如果我们只需要执行一次搜索，那么只进行线性搜索会更快，因为排序比线性搜索需要更长的时间。如果我们要执行大量搜索，通常值得先对数据进行排序，以便我们可以对重复搜索使用二分搜索。

您可以在我们的Binary Search Explore Card上找到更多关于二分搜索的信息。对于数组 101，您可以使用线性搜索或二分搜索。



希望三个基本的 Array 操作现在已经清楚了！像往常一样，您现在有几个问题可以自己尝试。

之后，我们将看看就地数组操作。你可能会问这些是什么？不过，让我们不要超越自己——你很快就会发现！

  In-Place Array Operations Introduction
Report Issue
In programming interviews, the interviewer often expects you to minimise the time and space complexity of your implementation. In-place Array operations help to reduce space complexity, and so are a class of techniques that pretty much everybody encounters regularly in interviews.

So, what are in-place array operations?

The best way of answering this question is to look at an example.

Given an Array of integers, return an Array where every element at an even-indexed position is squared.

Input: array = [9, -2, -9, 11, 56, -12, -3]
Output: [81, -2, 81, 11, 3136, -12, 9]
Explanation: The numbers at even indexes (0, 2, 4, 6) have been squared, 
whereas the numbers at odd indexes (1, 3, 5) have been left the same.
This problem is hopefully very straightforward. Have a quick think about how you would implement it as an algorithm though, possibly jotting down some code on a piece of paper.

Anyway, there are two ways we could approach it. The first is to create a new Array, of the same size as the original. Then, we should copy the odd-indexed elements and square the even-indexed elements, writing them into the new Array.

public int[] squareEven(int[] array,int length){
    //check for edge cases
    if(array==null){return null;}
    //create a arry hold the result;
    int result[]=new int[length];
    //iterate through the original array
    for(int i=0;i<length;i++){
        if(i%2==0){
            element*=element;
        }
        result[i]=element;
}
return result;
}


The above approach, although correct, is an inefficient way of solving the problem. This is because it uses O(\text{length})O(length) extra space.

Instead, we could iterate over the original input Array itself, overwriting every even-indexed element with its own square. This way, we won't need that extra space. It is this technique of working directly in the input Array, and not creating a new Array, that we call in-place. In-place Array operations are a big deal for programming interviews, where there is a big focus on minimising both time and space complexity of algorithms.

Here's the in-place implementation for our squareEven(...) function.

public int[] squareEven(int[] array,int length){
    if(array==null){
        return array;
    }
    for(int i=0;i<length;i++){
        if(i%2==0){
            array[i]*=array[i];
        }
    }
    return array;
}

An important difference for in-place vs not in-place is that in-place modifies the input Array. This means that other functions can no longer access the original data, because it has been overwritten. We'll talk more about this in a bit.



We now have a couple of straightforward in-place problems for you to try. Remember, you aren't allowed to create any new Arrays (or any other data structures). If the return type of the question is an Array, then simply return the input Array once you've modified it.


//  A Better Repeated Deletion Algorithm - Intro
Report Issue
Let's look at one more example. This time, the result Array is smaller than the input Array! How's this going to work? Let's find out! Here's the problem description:

Given a sorted array, remove the duplicates such that each element appears only once.

Input: array = [1, 1, 2]
Output: [1, 2]
Input: array = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
Output: [0, 1, 2, 3, 4]
You've hopefully already done this question, back when we were looking at deleting items from an Array. In that case, your algorithm might have looked something like this.

class Solution {
    public int removeDuplicates(int[] nums) {
        // The initial length is simply the capacity.
        int length=nums.length;

         // Assume the last element is always unique.
        // Then for each element, delete it iff it is
        // the same as the one after it. Use our deletion
        // algorithm for deleting from any index.
        for(int i=length-2;i>=0;i--){
            if(nums[i]=nums[i+1]){
                // Delete the element at index i, using our standard
                // deletion algorithm we learned.
                for(int j=i+1;j<length;j++){
                    nums[j-1]=nums[j];
                }
                length--;

            }
        }
        return length;
    }
}


This is actually an in-place algorithm, because it doesn't require any extra space—its space complexity is O(1)O(1). However, the time complexity's not so flash, at O(N^2)O(N 
2
 ). This is because of the nested loop.

We want to get the algorithm down to an O(N)O(N) time complexity.

If we don't try to do this in-place, then it's straightforward. We could simply iterate through the Array, adding all unique elements to a new Array. Seeing as the the input Array is sorted, we can easily identify all unique elements, as they are the first element, and then any element that is different to the one before it.

One potential problem is that we actually don't know how long the result Array needs to be. Remember how that must be decided when the Array is created? The best solution for this problem is to do an initial pass, counting the number of unique elements. Then, we can create the result Array and do a second pass to add the elements into it. Here's the code for this approach.


public int[] compyWithRemovedDuplicates(int[] nums){
    //check for edge cases
    if(nums==null||nums.length==0){
        return nums;
    }
    //count how many unique elements are in the Array.
    int uniqueNumbers=0;
    for(int i=0;i<nums.length;i++){
        if(i==0||nums[i]!=nums[i-1]){
             // An element should be counted as unique if it's the first
      // element in the Array, or is different to the one before it.
            uniqueNumbers++;
        }
    }
    int[] result=new int[uniqueNumbers];
    // Write the unique elements into the result Array.

    int positionInResult=0;
    for(int i=0;i<nums.length;i++){
        // Same condition as in the previous loop. Except this time, we can write
    // each unique number into the result Array instead of just counting them.
        if(i==0||nums[i]!=nums[i-1]){
            result[positionInResult]=nums[i];
            positionInResult++;
        }
    }
    return result;
}

Did you notice the fatal flaw with this approach though? It's the wrong return type! We could copy the result array back into the input array... and then return the length... but this is not what the question wants us to do. We want to instead do the deletions with a space complexity of O(1)O(1) and a time complexity of O(N)O(N).



Have a go at this for yourself, and then we'll talk about the solution. Your algorithm must be in-place, and take no more than O(N)O(N) time. Good luck!

//A Better Repeated Deletion Algorithm - Answer
Report Issue
Anyway, the algorithm with O(N)O(N) space is surprisingly similar to the one without. Interestingly, it's simpler though, because it doesn't need to firstly determine the size of the output.

Implementing this requires the use of the two-pointer technique. This is where we iterate over the Array in two different places at the same time.

Read all the elements like we did before, to identify the duplicates. We call this our readPointer.
Keep track of the next position in the front to write the next unique element we've found. We call this our writePointer.

public int removeDuplicates(int[] nums){
    //check for edge cases.
    if(nums==null){
        return 0;
    }

    // Use the two pointer technique to remove the duplicates in-place.
  // The first element shouldn't be touched; it's already in its correct place.
    int writePointer=1;
    // go through each element in the array.
    for(int readPointer=1;readPointer<nums.length;readPointer++){
        // If the current element we're reading is *different* to the previous
      // element...
        if(nums[readPointer]!=nums[readPointer-1]){
            // Copy it into the next position at the front, tracked by writePointer.
            nums[writePointer]=nums[readPointer];
            // And we need to now increment writePointer, because the next element
          // should be written one space over.
            writePointer++;
        }
        
    }
    // This turns out to be the correct length value.
    return writePointer;
}

You're quite possibly surprised that this even works. How are we not overwriting any elements that we haven't yet looked at?! The key thing to notice is that the condition is such that it is impossible for writePointer to ever get ahead of the readPointer. This means that we would never overwrite a value that we haven't yet read

This was just a very brief introduction to the very versatile and widely used two-pointer technique. It is one of the main techniques used for in-place Array algorithms. We'll be looking at it further in the next Array explore card!

You're quite possibly surprised that this even works. How are we not overwriting any elements that we haven't yet looked at?! The key thing to notice is that the condition is such that it is impossible for writePointer to ever get ahead of the readPointer. This means that we would never overwrite a value that we haven't yet read

This was just a very brief introduction to the very versatile and widely used two-pointer technique. It is one of the main techniques used for in-place Array algorithms. We'll be looking at it further in the next Array explore card!

 下一步是什么？
报告问题
让我们回顾一下我们在这张探索卡中看到的内容：

我们探索了 Array 数据结构的全部内容。
我们查看了用于创建数组的 Java 语法。
我们查看了从数组读取和写入的 Java 语法。
我们为数组设计了基本的插入、删除和搜索算法。
我们使用了就地数组算法。
我们解决了大量有趣和令人兴奋的问题！
在 LeetCode，我们已经开始开发后续的 Arrays Explore Card！在这张卡片中，我们将讨论一些更高级的处理数组的技术。

您可能想知道数组还有哪些其他技术？好吧，别再想了。这是一个快速品尝者！

两点

圆形阵列

不过现在，这里有一些最后的问题供您真正练习所学，并为下一张阵列探索卡做好准备！


//https://leetcode.com/explore/learn/card/array-and-string/201/introduction-to-array/1143/
Array and String

 Introduction to Array
Report Issue
An array is a basic data structure to store a collection of elements sequentially. But elements can be accessed randomly since each element in the array can be identified by an array index.

An array can have one or more dimensions. Here we start with the one-dimensional array, which is also called the linear array. Here is an example:



In the above example, there are 6 elements in array A. That is to say, the length of A is 6. We can use A[0] to represent the first element in the array. Therefore, A[0] = 6. Similarly, A[1] = 3, A[2] = 8 and so on.

 

Operations in Array
Let's take a look at the usage of the array.

public class Main{
    public static void main(String[] args) {
        //1.init
        int[] a0=new int[5];
        int[] a1={1,2,3};
        //2.get length
        System.out.println("size of a1 is:"+a1.legnth);
        //3.access elements
        System.out.println("the first element is:"+a1[0]);
        //4.iterate all elements
        System.out.print("[Version 1] The contents of a1 are:");
        for(int i=0;i<a1.length;++i){
            System.out.println(""+a1[i]);
        }
        System.out.println();
        System.out.print("[Version 2] The contents of a1 are:");
        for(int item:a1){
            System.out.print(""+item);
        }
        System.out.println();
        //5 modify element
        a1[0]=4;
        //6 sort
        Array.sort(a1);
    }
}

//Introduction to Dynamic Array
Report Issue
As we mentioned in the previous article, an array has a fixed capacity and we need to specify the size of the array when we initialize it. Sometimes this will be somewhat inconvenient and wasteful.

Therefore, most programming languages offer built-in dynamic array which is still a random access list data structure but with variable size. For example, we have vector in C++ and ArrayList in Java.

public class Main{
    public static void main(String[] args) {
        //1.initialize
        List<Integer> v0=new ArrayList<>();
        List<Integer> v1; //v1=null
        //2 cast an array to a vector
        Integer[] a={0,1,2,3,4}; 
        v1=new ArrayList<>(Arrays.asList(a));
        //3 make a copy
        List<Integer> v2=v1; //make another reference to v1
        List<Integer> v3=new ArrayList<v1>; //make actual copy of v1
        //get length
        System.out.println("the size of v1 is"+v1.size());
        //access element
        System.out.println("THE first element in v1 is:"+v1.get(0));
        //iterative the vector
        System.out.print("[Version 1] The contents of v1 are:");
        for(int i=1;i<v1.size();++i){
            System.out.println(""+v1.get(i));
        }
        System.out.println();
        System.out.print("[Version 2] The contents of v1 are:");
        for(int item:v1){
            System.out.print(""+item);
        }
        System.out.println();
        //modify element
        v2.set(0,5); //modify v2 will modify v1
        System.out.println("The first element in v1 is: " + v1.get(0));
        v3.set(0,-1);
        System.out.println("The first element in v1 is: " + v1.get(0));
        //SORT
        Collections.sort(v1);
        //sort() present in java.util; collection class. used to sort the elements presented in the list of collection in asending order
        //add new element at the end of the vector
        v1.add(-1);
        v1.add(1,6);
        //delete the last element
        v1.remove(v1.size()-1);
    }
}


 Introduction to 2D Array
Report Issue
Similar to a one-dimensional array, a two-dimensional array also consists of a sequence of elements. But the elements can be laid out in a rectangular grid rather than a line.

 

An Example
Let's take a look at an example of using a two-dimensional array:

// "static void main" must be defined in a public class.
public class Main {
    private static void printArray(int[][] a) {
        for (int i = 0; i < a.length; ++i) {
            System.out.println(a[i]);
        }
        for (int i = 0; i < a.length; ++i) {
            for (int j = 0; a[i] != null && j < a[i].length; ++j) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }
    public static void main(String[] args) {
        System.out.println("Example I:");
        int[][] a = new int[2][5];
        printArray(a);
        System.out.println("Example II:");
        int[][] b = new int[2][];
        printArray(b);
        System.out.println("Example III:");
        b[0] = new int[3];
        b[1] = new int[5];
        printArray(b);
    }
}

Principle
In some languages, the multidimensional array is actually implemented internally as a one-dimensional array while in some other languages, there is actually no multidimensional array at all.

 

1. C++ stores the two-dimensional array as a one-dimensional array.

The picture below shows the actual structure of a M * N array A:

So actually A[i][j] equals to A[i * N + j] if we defined A as a one-dimensional array which also contains M * N elements.

 

2. In Java, the two-dimensional array is actually a one-dimensional array which contains M elements, each of which is an array of N integers.

The picture below shows the actual structure of a two-dimensional array A in Java:



 

Dynamic 2D Array
Similar to the one-dimensional dynamic array, we can also define a dynamic two-dimensional array. Actually, it can be just a nested dynamic array. You can try it out by yourself.

 Introduction to String
Report Issue
A string is actually an array of unicode characters. You can perform almost all the operations we used in an array. You can try it out by yourself.

However, there are some differences. In this article, we will go through some of them which you should be aware of when dealing with a string. These features might vary a lot from one language to another. 

 

Compare Function
String has its own compare function (we will show you the usage of compare function in the code below).

However, there is a problem:

Can we use "==" to compare two strings?

It depends on the answer to the question:

Does the language support operator overloading?

If the answer is yes (like C++), we may use "==" to compare two strings.
If the answer is no (like Java), we may not use "==" to compare two strings. When we use "==", it actually compares whether these two objects are the same object.
Let's run the following example and compare the results:

// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // initialize
        String s1 = "Hello World";
        System.out.println("s1 is \"" + s1 + "\"");
        String s2 = s1;
        System.out.println("s2 is another reference to s1.");
        String s3 = new String(s1);
        System.out.println("s3 is a copy of s1.");
        // compare using '=='
        System.out.println("Compared by '==':");
        // true since string is immutable and s1 is binded to "Hello World"
        System.out.println("s1 and \"Hello World\": " + (s1 == "Hello World"));
        // true since s1 and s2 is the reference of the same object
        System.out.println("s1 and s2: " + (s1 == s2));
        // false since s3 is refered to another new object
        System.out.println("s1 and s3: " + (s1 == s3));
        // compare using 'equals'
        System.out.println("Compared by 'equals':");
        System.out.println("s1 and \"Hello World\": " + s1.equals("Hello World"));
        System.out.println("s1 and s2: " + s1.equals(s2));
        System.out.println("s1 and s3: " + s1.equals(s3));
        // compare using 'compareTo'
        System.out.println("Compared by 'compareTo':");
        System.out.println("s1 and \"Hello World\": " + (s1.compareTo("Hello World") == 0));
        System.out.println("s1 and s2: " + (s1.compareTo(s2) == 0));
        System.out.println("s1 and s3: " + (s1.compareTo(s3) == 0));
    }
}

Immutable or Mutable
Immutable means that you can't change the content of the string once it's initialized.

I
In some other languages (like Java), the string is immutable. This feature will bring several problems. We will illustrate the problems and solutions in the next article.
You can determine whether the string in your favorite language is immutable or mutable by testing the modification operation. Here is an example:

// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        String s1 = "Hello World";
        s1[5] = ',';
        System.out.println(s1);
    }
}

Extra Operations
Compare to an array, there are some extra operations we can perform on a string. Here are some examples:

public class Main{
    public static void main(String[] args) {
        String s1="hello world";
        //1concentrate
        s1+="!"
         System.out.println(s1);
        // 2. find
         System.out.println("position of the first o is"+s1.indexOf('o'));
         System.out.println("position of the last o is"+s1.lastIndexOf('o'));
         //3 get substring
         System.out.println(s1.substring(6,11));
    }
}
Hello World!
The position of first 'o' is: 4
The position of last 'o' is: 7
World

您应该了解the time complexity这些内置操作。

例如，如果字符串的长度为N，则查找操作和子字符串操作的时间复杂度均为O(N)。

此外，在字符串不可变的语言中，您应该小心连接操作（我们也会在下一篇文章中解释这一点）。

在计算解决方案的时间复杂度时，永远不要忘记考虑内置操作的时间复杂度。


  Immutable String - Problems & Solutions
Report Issue
You should know whether the string in your favorite language is immutable or not in the previous article. If the string is immutable, it will bring some problems. Hopefully, we will also provide the solution at the end.

 

Modification Operation
Obviously, an immutable string cannot be modified. If you want to modify just one of the characters, you have to create a new string.

 

Beware of String Concatenation in Java
You should be very careful with string concatenation. Let's look at an example when we do string concatenation repeatedly in a for loop:


public class Main{
    public static void main(String[] args) {
        String s="";
        int n=10000;
        for(int i=0;i<n;i++){
            s+="hello";
        }
    }
}

Notice how slow string concatenation is for Java? On the other hand, there is no noticeable performance impact in C++.

In Java, since the string is immutable, concatenation works by first allocating enough space for the new string, copy the contents from the old string and append to the new string.

Therefore, the time complexity in total will be:

   5 + 5 × 2 + 5 × 3 + … + 5 × n
= 5 × (1 + 2 + 3 + … + n)
= 5 × n × (n + 1) / 2,

which is O(n2).

 

Solutions
If you want your string to be mutable, there are some substitutions:

public class Main{
    public static void main(String[] args) {
        String s="Hello world";
        char str.s.toCharArray();
        str[5]=",";
        System.out.println(str);
    }
}

//Finished in 164 ms
//Hello,World

2. If you have to concatenate strings often, it will be better to use some other data structures like StringBuilder. The below code runs in O(n) complexity.
public class Main{
    public static void main(String[] args) {
        int n=10000;
        StringBuilder str=new StringBuilder();
        for(int i=0;i<n;i++){
            str.append("hello");
        }
        String s=str.toString();
    }
}

 Two-pointer Technique - Scenario I
Report Issue
In the previous chapter, we solve some problems by iterating the array. Typically, we only use one pointer starting from the first element and ending at the last one to do iteration. However, sometimes, we might need to use two pointers at the same time to do the iteration.

 

An Example
Let's start with a classic problem:

Reverse the elements in an array.

The idea is to swap the first element with the end, advance to the next element and swapping repeatedly until it reaches the middle position. 

We can use two pointers at the same time to do the iteration: one starts from the first element and another starts from the last element. Continue swapping the elements until the two pointers meet each other.

Here is the code for your reference:

public static void reverse(int[] v,int N){
    int i=0;
    int j=N-1;
    while(i<j){
        swap(v,i,j); //self-defined
        i++;
        j--;
    }
}

Summary
To summarize, one of the typical scenarios to use two-pointer technique is that you want to

Iterate the array from two ends to the middle.

So you can use the two-pointer technique:

One pointer starts from the beginning while the other pointer starts from the end.

And it is worth noting that this technique is often used in a sorted array.


// Two-pointer Technique - Scenario II
Report Issue
Sometimes, we can use two pointers with different steps to solve problems.

 

An Example
Let's start with another classic problem:

Given an array and a value, remove all instances of that value in-place and return the new length.

If we don't have the limitation of space complexity, it will be easier. We can initialize a new array to store the answer. Iterate the original array and add the element to the new array if the element is not equal to the given target value.

Actually, it is equivalent to using two pointers, one is used for the iteration of the original array and another one always points at the last position of the new array.

Reconsider the Space Limitation
Now let's reconsider the space limitation.

We can use a similar strategy. We still use two pointers: one is still used for the iteration while the second one always points at the position for next addition.

Here is the code for your reference:

public int removeElement(int[] nums,int val){
    int k=0;
    for(int i=0;i<nums.length;++i){
        if(nums[i]!=val){
            nums[k]=nums[i];
            k++
        }
    }
}

We use two pointers, one faster-runner i and one slower-runner k, in the example above. i moves one step each time while k moves one step only if a new needed value is added.

Summary
This is a very common scenario of using the two-pointer technique when you need:

One slow-runner and one fast-runner at the same time.

The key to solving this kind of problems is to

Determine the movement strategy for both pointers.

Similar to the previous scenario, you might sometimes need to sort the array before using the two-pointer technique. And you might need a greedy thought to determine your movement strategy.


Array-related Techniques
Report Issue
There are more array-related data structures or techniques you might want to know. We will not go deeper into most of the concepts in this card but provide the links to the corresponding card in this article.

1. There are some other data structures which are similar to the array but have some different properties:

String (has been introduced in this card)
Hash Table
Linked List
Queue
Stack
2. As we mentioned, we can call the built-in function to sort an array. But it is useful to understand the principle of some widely-used sorting algorithms and their complexity.

3. Binary search is also an important technique used to search a specific element in a sorted array.

4. We have introduced two-pointer technique in this chapter. It is not easy to use this technique flexibly. This technique can also be used to solve:

Slow-pointer and fast-pointer problem in Linked List
Sliding Window Problem
5. The two-pointer technique sometimes will relate to Greedy Algorithm which helps us design our pointers' movement strategy.

We will come up with more cards to introduce these techniques mentioned above and update the link in the near future.


Introduction - Singly Linked List
Report Issue
Each node in a singly-linked list contains not only the value but also a reference field to link to the next node. By this way, the singly-linked list organizes all the nodes in a sequence.

Here is an example of a singly-linked list:



The blue arrows show how nodes in a singly linked list are combined together.

 

Node Structure
Here is the typical definition of a node in a singly-linked list:

//definition of singly-linked list
public class SinglyListNode{
    int val;
    SinglyListNode next;
    SinglyListNode(int x){
        val=x;
    }
}

In most cases, we will use the head node (the first node) to represent the whole list.

 

Operations
与数组不同，我们无法在恒定时间内访问单向链表中的随机元素。如果我们想要得到第 i个元素，我们必须从头节点开始一个一个地遍历。我们O(N)平均花费时间到visit an element by index，其中N是链表的长度。

例如，在上面的例子中，头是节点23。访问第三个节点的唯一方法是使用头节点的“next”字段到达第二个节点（节点6）；然后使用节点 6 的“next”字段，我们可以访问第三个节点。

您可能想知道为什么链表很有用，尽管它在按索引访问数据时具有如此糟糕的性能（与数组相比）。我们将在接下来的两篇文章中介绍insert和 delete操作，您将体会到链表的好处。

之后，我们为您提供一个练习来设计您自己的单向链表。

Add Operation - Singly Linked List
Report Issue
If we want to add a new value after a given node prev, we should: 

Initialize a new node cur with the given value;
Link the "next" field of cur to prev's next node next;
Link the "next" field in prev to cur.
Unlike an array, we don’t need to move all elements past the inserted element. Therefore, you can insert a new node into a linked list in O(1) time complexity, which is very efficient.

 

An Example


Let's insert a new value 9 after the second node 6.

We will first initialize a new node with value 9. Then link node 9 to node 15. Finally, link node 6 to node 9.

After insertion, our linked list will look like this:



 
Add a Node at the Beginning
As we know, we use the head node head to represent the whole list.

So it is essential to update head when adding a new node at the beginning of the list.

Initialize a new node cur;
Link the new node to our original head node head.
Assign cur to head.
For example, let's add a new node 9 at the beginning of the list.

We initialize a new node 9 and link node 9 to current head node 23.
Assign node 9 to be our new head.
What about adding a new node at the end of the list? Can we still use similar strategy?


Delete Operation - Singly Linked List
Report Issue
If we want to delete an existing node cur from the singly linked list, we can do it in two steps:

Find cur's previous node prev and its next node next;
Link prev to cur's next node next.
In our first step, we need to find out prev and next. It is easy to find out next using the reference field of cur. 

**However, we have to traverse the linked list from the head node to find out prev which will take O(N) time** on average, where N is the length of the linked list. So the time complexity of deleting a node will be O(N).

The space complexity is O(1) because we only need constant space to store our pointers.

An Example


Let's try to delete node 6 from the singly linked list above.

1. Traverse the linked list from the head until we find the previous node prev which is node 23

2. Link prev (node 23) with next (node 15)



Node 6 is not in our singly linked list now.

 

Delete the First Node
If we want to delete the first node, the strategy will be a little different.

As we mentioned before, we use the head node head to represent a linked list. Our head is the black node 23 in the example below.



If we want to delete the first node, we can simply assign the next node to head. That is to say, our head will be node 6 after deletion.



The linked list begins at the head node, so node 23 is no longer in our linked list.

What about deleting the last node? Can we still use similar strategy?

// Two-Pointer in Linked List
Report Issue
Let's start with a classic problem:

Given a linked list, determine if it has a cycle in it.

You might have come up with the solution using the hash table. But there is a more efficient solution using the two-pointer technique. Try to think it over by yourself before reading the remaining content.

Imagine there are two runners with different speed. If they are running on a straight path, the fast runner will first arrive at the destination. However, if they are running on a circular track, the fast runner will catch up with the slow runner if they keep running.

That's exactly what we will come across using two pointers with different speed in a linked list:

If there is no cycle, the fast pointer will stop at the end of the linked list.
If there is a cycle, the fast pointer will eventually meet with the slow pointer.
So the only remaining problem is:

What should be the proper speed for the two pointers?

It is a safe choice to move the slow pointer one step at a time while moving the fast pointer two steps at a time. For each iteration, the fast pointer will move one extra step. If the length of the cycle is M, after M iterations, the fast pointer will definitely move one more cycle and catch up with the slow pointer.

What about other choices? Do they work? Would they be more efficient?

//Summary - Two-Pointer in Linked List
Report Issue
Here we provide a template for you to solve the two-pointer problem in the linked list.

//initialize slow & faster pointers
ListNode slow=head;
ListNode fast=head;
//chage this contition to fit specific problem.
//attention: remember to avoid null-pointer error

while(slow!=null&&fast!=null&&fast.next!=null){
    slow=slow.next;
    fast=fast.next.next;
    if(slow==fast){
        return true;
    }
}
return false;

//Summary - Two-Pointer in Linked List
Report Issue
Here we provide a template for you to solve the two-pointer problem in the linked list.



 

Tips
It is similar to what we have learned in an array. But it can be trickier and error-prone. There are several things you should pay attention:

1. Always examine if the node is null before you call the next field.

Getting the next node of a null node will cause the null-pointer error. For example, before we run fast = fast.next.next, we need to examine both fast and fast.next is not null.

2. Carefully define the end conditions of your loop.

Run several examples to make sure your end conditions will not result in an endless loop. And you have to take our first tip into consideration when you define your end conditions.

 

Complexity Analysis
It is easy to analyze the space complexity. If you only use pointers without any other extra space, the space complexity will be O(1). However, it is more difficult to analyze the time complexity. In order to get the answer, we need to analyze how many times we will run our loop .

In our previous finding cycle example, let's assume that we move the faster pointer 2 steps each time and move the slower pointer 1 step each time.

If there is no cycle, the fast pointer takes N/2 times to reach the end of the linked list, where N is the length of the linked list.
If there is a cycle, the fast pointer needs M times to catch up the slower pointer, where M is the length of the cycle in the list.
Obviously, M <= N. So we will run the loop up to N times. And for each loop, we only need constant time. So, the time complexity of this algorithm is O(N) in total.

Analyze other problems by yourself to improve your analysis skill. Don't forget to take different conditions into consideration. If it is hard to analyze for all situations, consider the worst one.


//Reverse Linked List
Report Issue
Let's start with a classic problem:

Reverse a singly linked list.

One solution is to iterate the nodes in original order and move them to the head of the list one by one. It seems hard to understand. We will first use an example to go through our algorithm. 

 

Algorithm Overview
Let's look at an example:



Keep in mind that the black node 23 is our original head node.

1. First, we move the next node of the black node, which is node 6, to the head of the list:



2. Then we move the next node of the black node, which is node 15, to the head of the list:



3. The next node of the black node now is null. So we stop and return our new head node 15.

 

More
In this algorithm, each node will be moved exactly once.

Therefore, the time complexity is O(N), where N is the length of the linked list. We only use constant extra space so the space complexity is O(1).

This problem is the foundation of many linked-list problems you might come across in your interview. If you are still stuck, our next article will talk more about the implementation details.

There are also many other solutions. You should be familiar with at least one solution and be able to implement it.


// Introduction - Doubly Linked List
Report Issue
We have introduced the singly linked list in previous chapters.

A node in a singly linked list has the value field, and a "next" reference field to link nodes sequentially.

In this article, we will introduce another type of linked list: Doubly Linked List.

 

Definition
The doubly linked list works in a similar way but has one more reference field which is known as the "prev" field. With this extra field, you are able to know the previous node of the current node.

Let's take a look at an example:



The green arrows indicate how our "prev" field works.

 

Node Structure
Here is a typical definition of the node structure in a doubly linked list:



Similar to the singly linked list, we will use the head node to represent the whole list.

 

Operations
Similar to a singly linked list, we will introduce how to access data, insert a new node or delete an existing node in a doubly linked list.

We can access data in the same exact way as in a singly linked list:

We are not able to access a random position in constant time.
We have to traverse from the head to get the i-th node we want.
The time complexity in the worse case will be O(N), where N is the length of the linked list.
For addition and deletion, it will be a little more complicated since we need to take care of the "prev" field as well. We will go through these two operations in next two articles.

After that, we provide an exercise for you to redesign the linked list using doubly linked list.

//Add Operation - Doubly Linked List
Report Issue
If we want to insert a new node cur after an existing node prev, we can divide this process into two steps:



link cur with prev and next, where next is the original next node of prev;
re-link the prev and next with cur. 
Similar to the singly linked list, both the time and the space complexity of the add operation are O(1).

An Example


Let's add a new node 9 after the existing node 6:

link cur (node 9) with prev (node 6) and next (node 15)
re-link prev (node 6) and next (node 15) with cur (node 9)
What if we want to insert a new node at the beginning or at the end?

Delete Operation - Doubly Linked List
Report Issue
If we want to delete an existing node cur from the doubly linked list, we can simply link its previous node prev with its next node next.

Unlike the singly linked list, it is easy to get the previous node in constant time with the "prev" field.

Since we no longer need to traverse the linked list to get the previous node, both the time and space complexity are O(1).

 

An Example

Our goal is to delete the node 6 from the doubly linked list.

So we link its previous node 23 and its next node 15:



Node 6 is not in our doubly linked list now.

What if we want to delete the first node or the last node?


Review
Let's briefly review the performance of the singly linked list and doubly linked list.

They are similar in many operations:

Both of them are not able to access the data at a random position in constant time.
Both of them can add a new node after given node or at the beginning of the list in O(1) time.
Both of them can delete the first node in O(1) time.
But it is a little different to delete a given node (including the last node).

In a singly linked list, it is not able to get the previous node of a given node so we have to spend O(N) time to find out the previous node before deleting the given node.
In a doubly-linked list, it will be much easier because we can get the previous node with the "prev" reference field. So we can delete a given node in O(1) time.
 

Comparison
Here we provide a comparison of time complexity between the linked list and the array.



Note: The given time complexities for the Doubly-Linked List assume that the Doubly-Linked List implementation keeps a reference to the tail node. If a reference to the tail node is not kept, then adding a node after the last node or deleting the last node would also require O(N) time.

After this comparison, it is not difficult to come up with our conclusion:

If you need to add or delete a node frequently, a linked list could be a good choice.

If you need to access an element by index often, an array might be a better choice than a linked list.




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































